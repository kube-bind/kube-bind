/*
Copyright 2025 The Kube Bind Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package oidc

import (
	"crypto/x509"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/kcp-dev/sdk/testing/third_party/library-go/crypto"
	"github.com/xrstf/mockoidc"
)

func TestLoadTLSConfig_Success(t *testing.T) {
	// Create a temporary CA file with the CA cert generated by the existing crypto package
	tmpDir := t.TempDir()
	caCertFile := filepath.Join(tmpDir, "test-ca.crt")
	caKeyFile := filepath.Join(tmpDir, "test-ca.key")

	// Use the same crypto package that the main code uses
	ca, _, err := crypto.EnsureCA(caCertFile, caKeyFile, "", "test-ca", 1)
	if err != nil {
		t.Fatalf("Failed to create test CA: %v", err)
	}

	// Verify the CA file was created
	if _, err := os.Stat(caCertFile); os.IsNotExist(err) {
		t.Fatalf("CA file was not created: %v", err)
	}

	// Test LoadTLSConfig
	config, err := LoadTLSConfig(caCertFile)
	if err != nil {
		t.Fatalf("LoadTLSConfig failed: %v", err)
	}

	// Verify the TLS config was created
	if config == nil {
		t.Fatal("Expected non-nil TLS config")
	}

	if config.RootCAs == nil {
		t.Fatal("Expected RootCAs to be set")
	}

	// Verify the CA was loaded by checking that we can verify the CA cert itself
	opts := x509.VerifyOptions{
		Roots: config.RootCAs,
	}

	_, err = ca.Config.Certs[0].Verify(opts)
	if err != nil {
		t.Fatalf("Failed to verify CA cert with loaded TLS config: %v", err)
	}
}

func TestLoadTLSConfig_FileNotFound(t *testing.T) {
	// Test with non-existent file
	config, err := LoadTLSConfig("/non/existent/path.crt")

	if err == nil {
		t.Fatal("Expected error for non-existent file")
	}

	if config != nil {
		t.Fatal("Expected nil config when error occurs")
	}

	// Verify error message
	expectedMsg := "failed to read CA file"
	if !strings.Contains(err.Error(), expectedMsg) {
		t.Errorf("Expected error to contain '%s', got: %v", expectedMsg, err)
	}
}

func TestLoadTLSConfig_InvalidPEM(t *testing.T) {
	// Create a temporary file with invalid PEM content
	tmpDir := t.TempDir()
	caFile := filepath.Join(tmpDir, "invalid-ca.crt")

	invalidContent := "this is not a valid PEM certificate"
	err := os.WriteFile(caFile, []byte(invalidContent), 0600)
	if err != nil {
		t.Fatalf("Failed to write invalid CA file: %v", err)
	}

	// Test LoadTLSConfig with invalid PEM
	config, err := LoadTLSConfig(caFile)

	if err == nil {
		t.Fatal("Expected error for invalid PEM content")
	}

	if config != nil {
		t.Fatal("Expected nil config when error occurs")
	}

	// Verify error message
	expectedMsg := "failed to append CA certs from PEM"
	if !strings.Contains(err.Error(), expectedMsg) {
		t.Errorf("Expected error to contain '%s', got: %v", expectedMsg, err)
	}
}

func TestLoadTLSConfig_EmptyFile(t *testing.T) {
	// Create a temporary empty file
	tmpDir := t.TempDir()
	caFile := filepath.Join(tmpDir, "empty-ca.crt")

	err := os.WriteFile(caFile, []byte(""), 0600)
	if err != nil {
		t.Fatalf("Failed to write empty CA file: %v", err)
	}

	// Test LoadTLSConfig with empty file
	config, err := LoadTLSConfig(caFile)

	if err == nil {
		t.Fatal("Expected error for empty file")
	}

	if config != nil {
		t.Fatal("Expected nil config when error occurs")
	}

	// Verify error message
	expectedMsg := "failed to append CA certs from PEM"
	if !strings.Contains(err.Error(), expectedMsg) {
		t.Errorf("Expected error to contain '%s', got: %v", expectedMsg, err)
	}
}

func TestLoadTLSConfig_MultipleCerts(t *testing.T) {
	// Create two different CA certificates
	tmpDir := t.TempDir()

	// Create first CA
	ca1CertFile := filepath.Join(tmpDir, "test-ca-1.crt")
	ca1KeyFile := filepath.Join(tmpDir, "test-ca-1.key")
	ca1, _, err := crypto.EnsureCA(ca1CertFile, ca1KeyFile, "", "test-ca-1", 1)
	if err != nil {
		t.Fatalf("Failed to create first test CA: %v", err)
	}

	// Create second CA
	ca2CertFile := filepath.Join(tmpDir, "test-ca-2.crt")
	ca2KeyFile := filepath.Join(tmpDir, "test-ca-2.key")
	ca2, _, err := crypto.EnsureCA(ca2CertFile, ca2KeyFile, "", "test-ca-2", 1)
	if err != nil {
		t.Fatalf("Failed to create second test CA: %v", err)
	}

	// Read both CA certificates and combine them
	ca1Data, err := os.ReadFile(ca1CertFile)
	if err != nil {
		t.Fatalf("Failed to read first CA file: %v", err)
	}

	ca2Data, err := os.ReadFile(ca2CertFile)
	if err != nil {
		t.Fatalf("Failed to read second CA file: %v", err)
	}

	// Write combined CA bundle
	combinedCAFile := filepath.Join(tmpDir, "combined-ca.crt")
	ca1Data = append(ca1Data, ca2Data...)
	err = os.WriteFile(combinedCAFile, ca1Data, 0600)
	if err != nil {
		t.Fatalf("Failed to write combined CA file: %v", err)
	}

	// Test LoadTLSConfig with multiple certs
	config, err := LoadTLSConfig(combinedCAFile)
	if err != nil {
		t.Fatalf("LoadTLSConfig failed with multiple certs: %v", err)
	}

	// Verify the TLS config was created
	if config == nil {
		t.Fatal("Expected non-nil TLS config")
	}

	if config.RootCAs == nil {
		t.Fatal("Expected RootCAs to be set")
	}

	// Verify both CAs were loaded by trying to verify both certificates
	opts := x509.VerifyOptions{
		Roots: config.RootCAs,
	}

	// Should be able to verify first CA cert
	_, err = ca1.Config.Certs[0].Verify(opts)
	if err != nil {
		t.Fatalf("Failed to verify first CA cert: %v", err)
	}

	// Should be able to verify second CA cert
	_, err = ca2.Config.Certs[0].Verify(opts)
	if err != nil {
		t.Fatalf("Failed to verify second CA cert: %v", err)
	}
}

func TestEnsureOfflineAccessScope(t *testing.T) {
	// Save original scopes
	originalScopes := make([]string, len(mockoidc.ScopesSupported))
	copy(originalScopes, mockoidc.ScopesSupported)

	// Reset to original scopes after test
	defer func() {
		mockoidc.ScopesSupported = originalScopes
	}()

	// Remove offline_access if it exists (to test adding)
	var filteredScopes []string
	for _, scope := range mockoidc.ScopesSupported {
		if scope != "offline_access" {
			filteredScopes = append(filteredScopes, scope)
		}
	}
	mockoidc.ScopesSupported = filteredScopes

	// Verify offline_access is not present
	hasOfflineAccess := false
	for _, scope := range mockoidc.ScopesSupported {
		if scope == "offline_access" {
			hasOfflineAccess = true
			break
		}
	}
	if hasOfflineAccess {
		t.Fatal("offline_access should not be present before calling ensureOfflineAccessScope")
	}

	// Call ensureOfflineAccessScope
	ensureOfflineAccessScope()

	// Verify offline_access is now present
	hasOfflineAccess = false
	for _, scope := range mockoidc.ScopesSupported {
		if scope == "offline_access" {
			hasOfflineAccess = true
			break
		}
	}
	if !hasOfflineAccess {
		t.Fatal("offline_access should be present after calling ensureOfflineAccessScope")
	}

	// Call again to test idempotency
	originalLength := len(mockoidc.ScopesSupported)
	ensureOfflineAccessScope()

	// Should not add it again
	if len(mockoidc.ScopesSupported) != originalLength {
		t.Fatal("ensureOfflineAccessScope should be idempotent")
	}
}
