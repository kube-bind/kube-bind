{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kube-bind Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>kube-bind is a prototype project that aims to provide better support for service providers and consumers that reside in distinct Kubernetes clusters.</p> <ul> <li>A service provider defines its API in terms of CRDs and associated permission claims/limitations, and exports it for use from other clusters.</li> <li>Service consumers identify the services they want to consume.</li> <li>The service CRDs get installed in the service consumer clusters, with objects of the defined kinds written and read by the service consumers.</li> <li>The service provider indirectly reads and writes those objects as the interface to the service that it provides.</li> <li>The service provider does not inject controllers/operators into the service consumer's cluster.</li> <li>A single vendor-neutral, OpenSource agent per consumer cluster connects it with the requested services.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To get started with trying out kube-bind on your local system, check out our Quickstart instructions.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We \u2764\ufe0f our contributors! If you're interested in helping us out, please head over to our Contributing guide.</p>"},{"location":"#getting-in-touch","title":"Getting in touch","text":"<p>There are several ways to communicate with us:</p> <ul> <li>The <code>#kube-bind</code> channel in the Kubernetes Slack workspace.</li> <li>Our mailing lists:<ul> <li>kube-bind-dev for development discussions.</li> </ul> </li> <li>By joining the kcp-dev mailing list, you should receive an invite to our bi-weekly community meetings.</li> </ul>"},{"location":"contributing/","title":"Contributing to kube-bind","text":"<p>kube-bind is Apache 2.0 licensed and we accept contributions via GitHub pull requests.</p> <p>Please read the following guide if you're interested in contributing to kcp.</p>"},{"location":"contributing/#certificate-of-origin","title":"Certificate of Origin","text":"<p>By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. See the DCO file for details.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ol> <li>Clone this repository.</li> <li>Install Go (currently 1.22).</li> <li>Install kubectl.</li> </ol>"},{"location":"contributing/#finding-areas-to-contribute","title":"Finding Areas to Contribute","text":"<p>Starting to participate in a new project can sometimes be overwhelming, and you may not know where to begin. Fortunately, we are here to help! We track all of our tasks here in GitHub, and we label our issues to categorize them. Here are a couple of handy links to check out:</p> <ul> <li>Good first issue issues</li> <li>Help wanted issues</li> </ul> <p>You're certainly not limited to only these kinds of issues, though! If you're comfortable, please feel free to try working on anything that is open.</p> <p>We do use the assignee feature in GitHub for issues. If you find an unassigned issue, comment asking if you can be assigned, and ideally wait for a maintainer to respond. If you find an assigned issue and you want to work on it or help out, please reach out to the assignee first.</p> <p>Sometimes you might get an amazing idea and start working on a huge amount of code. We love and encourage excitement like this, but we do ask that before you embarking on a giant pull request, please reach out to the community first for an initial discussion. You could file an issue, send a discussion to our mailing list, and/or join one of our community meetings.</p> <p>Finally, we welcome and value all types of contributions, beyond \"just code\"! Other types include triaging bugs, tracking down and fixing flaky tests, improving our documentation, helping answer community questions, proposing and reviewing designs, etc.</p>"},{"location":"contributing/#getting-your-pr-merged","title":"Getting your PR Merged","text":"<p>The <code>kube-bind</code> project uses <code>OWNERS</code> files to denote the collaborators who can assist you in getting your PR merged.  There are two roles: reviewer and approver.  Merging a PR requires sign off from both a reviewer and an approver.</p>"},{"location":"contributing/#community-roles","title":"Community Roles","text":""},{"location":"contributing/#reviewers","title":"Reviewers","text":"<p>Reviewers are responsible for reviewing code for correctness and adherence to standards. Oftentimes reviewers will be able to advise on code efficiency and style as it relates to golang or project conventions as well as other considerations that might not be obvious to the contributor.</p>"},{"location":"contributing/#approvers","title":"Approvers","text":"<p>Approvers are responsible for sign-off on the acceptance of the contribution. In essence, approval indicates that the change is desired and good for the project, aligns with code, api, and system conventions, and appears to follow all required process including adequate testing, documentation, follow ups, or notifications to other areas who might be interested or affected by the change.</p> <p>Approvers are also reviewers.</p>"},{"location":"contributing/#management-of-owners-files","title":"Management of <code>OWNERS</code> Files","text":"<p>If a reviewer or approver no longer wishes to be in their current role it is requested that a PR be opened to update the <code>OWNERS</code> file. <code>OWNERS</code> files may be periodically reviewed and updated based on project activity or feedback to ensure an acceptable contributor experience is maintained.</p>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/","title":"Publishing a New kube-bind Release","text":"<p>Note</p> <p>You currently need write access to the kube-bind/kube-bind repository to perform these tasks.</p>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#create-git-tags","title":"Create git Tags","text":""},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#prerequisite-make-sure-you-have-a-gpg-signing-key","title":"Prerequisite - Make Sure You Have a GPG Signing Key","text":"<ol> <li>https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key</li> <li>https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-gpg-key-to-your-github-account</li> <li>https://docs.github.com/en/authentication/managing-commit-signature-verification/telling-git-about-your-signing-key</li> </ol>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#create-the-tags","title":"Create the Tags","text":"<p>kube-bind has 3 go modules, and a unique tag is needed for each module every time we create a new release.</p> <ol> <li><code>git fetch</code> from the main kube-bind repository (kube-bind/kube-bind) to ensure you have the latest commits</li> <li>Tag the main module</li> <li>If your git remote for kube-bind/kube-bind is named something other than <code>upstream</code>, change <code>REF</code> accordingly</li> <li> <p>If you are creating a release from a release branch, change <code>main</code> in <code>REF</code> accordingly, or you can       make <code>REF</code> a commit hash.</p> <pre><code>REF=upstream/main\nTAG=v0.5.1\ngit tag --sign --message \"$TAG\" \"$TAG\" \"$REF\"\n</code></pre> </li> <li> <p>Tag the <code>sdk</code> module, following the same logic as above for <code>REF</code> and <code>TAG</code></p> </li> </ol> <pre><code>   REF=upstream/main\n   TAG=v0.5.1\n   git tag --sign --message \"sdk/$TAG\" \"sdk/$TAG\" \"$REF\"\n</code></pre> <ol> <li> <p>Tag the <code>cli</code> module, following the same logic as above for <code>REF</code> and <code>TAG</code></p> <pre><code>REF=upstream/main\nTAG=v0.5.1\ngit tag --sign --message \"cli/$TAG\" \"cli/$TAG\" \"$REF\"\n</code></pre> </li> </ol>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#push-the-tags","title":"Push the Tags","text":"<pre><code>REMOTE=upstream\nTAG=v0.5.1\ngit push \"$REMOTE\" \"$TAG\" \"sdk/$TAG\" \"cli/$TAG\"\n</code></pre>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#if-its-a-new-minor-version","title":"If it's a New Minor Version","text":"<pre><code>If this is the first release of a new minor version (e.g. the last release was v0.7.x, and you are releasing the first\n0.8.x version), follow the following steps.\n\nOtherwise, you can skip to [Generate release notes](#generate-release-notes).\n</code></pre>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#generate-release-notes","title":"Generate Release Notes","text":"<p>To generate release notes from the information in PR descriptions you should use Kubernetes' release-notes tool. This tool will use the <code>release-notes</code> blocks in PR descriptions and the <code>kind/</code> labels on those PRs to find user-facing changes and categorize them. You can run the command below to install the latest version of it:</p> <pre><code>go install k8s.io/release/cmd/release-notes@latest\n</code></pre> <p>To use <code>release-notes</code> you will need to generate a GitHub API token (Settings -&gt; Developers settings -&gt; Personal access tokens -&gt; Fine-grained tokens). A token with Public Repositories (read-only) repository access and no further permissions is sufficient. Store the token somewhere safe and export it as <code>GITHUB_TOKEN</code> environment variable.</p> <p>Then, run run the <code>release-notes</code> tool (set <code>PREV_VERSION</code> to the version released before the one you have just released).</p> <pre><code>TAG=v0.5.0\nPREV_TAG=v0.4.8\nrelease-notes \\\n  --required-author='' \\\n  --org kube-bind \\\n  --repo kube-bind \\\n  --branch main \\\n  --start-rev $PREV_TAG \\\n  --end-rev $TAG \\\n  --output CHANGELOG.md \n</code></pre> <p>Don't commit the <code>CHANGELOG.md</code> to the repository, just keep it around to update the release on GitHub (next step).</p>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#revieweditpublish-the-release-in-github","title":"Review/Edit/Publish the Release in GitHub","text":"<p>The goreleaser workflow automatically creates a draft GitHub release for each tag.</p> <ol> <li>Navigate to the draft release for the tag you just pushed. You'll be able to find it under the releases page.</li> <li>If the release notes have been pre-populated, delete them.</li> <li>Copy release notes from the <code>CHANGELOG.md</code> file you generated in the previous step.</li> <li>Publish the release.</li> </ol>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#trigger-documentation-deployment","title":"Trigger Documentation Deployment","text":"<p>Documentation for the respective release branch needs to be triggered manually after the release branch has been pushed.</p> <ol> <li>Navigate to the Generate and push docs GitHub Action.</li> <li>Hit the \"Run forkflow\" button, run workflow against <code>release-$VERSION</code>.</li> <li>Make sure the triggered workflow ran and deployed a new version of the documentation to https://docs.kube-bind.io/main/.</li> </ol>"},{"location":"contributing/guides/publishing-a-new-kube-bind-release/#notify","title":"Notify","text":"<ol> <li>Create an email addressed to kube-bind-dev@googlegroups.com with:<ol> <li>Subject: <code>[release] &lt;version&gt;</code> e.g. <code>[release] v0.5.0</code></li> <li>In the body, include noteworthy changes</li> <li>Provide a link to the release in GitHub for the full release notes</li> </ol> </li> <li>Post a message in the #kube-bind Slack channel</li> </ol>"},{"location":"developers/","title":"Developers","text":""},{"location":"developers/backend/","title":"Backend","text":"<p>The kube-bind backend provides service export and binding capabilities for single Kubernetes clusters acting as backend or many clusters with support for multiple cluster providers through the multicluster-runtime architecture.</p>"},{"location":"developers/backend/#architecture","title":"Architecture","text":"<p>Starting with v0.5.0, the backend leverages <code>sigs.k8s.io/multicluster-runtime</code> for enhanced cluster management capabilities.</p>"},{"location":"developers/backend/#key-components","title":"Key Components","text":"<ul> <li>MultiCluster Runtime Integration: Built on <code>sigs.k8s.io/multicluster-runtime</code> for provider-agnostic cluster operations</li> <li>Provider Support: Extensible provider system supporting different backend implementations</li> <li>Manager Architecture: Uses <code>mcmanager.Manager</code> for cluster-aware resource management</li> </ul>"},{"location":"developers/backend/#supported-providers","title":"Supported Providers","text":"<ul> <li>Default Provider: Standard Kubernetes cluster support</li> <li>KCP Provider: Integration with kcp through <code>github.com/kcp-dev/multicluster-provider</code></li> </ul>"},{"location":"developers/backend/#configuration","title":"Configuration","text":"<p>The backend can be configured to use different providers:</p> <pre><code>./bin/backend \\\n  --multicluster-runtime-provider kcp \\\n  --server-url=$(kubectl get apiexportendpointslice kube-bind.io -o jsonpath=\"{.status.endpoints[0].url}\") \\\n  # ... other options\n</code></pre>"},{"location":"developers/backend/#provider-configuration","title":"Provider Configuration","text":""},{"location":"developers/backend/#kcp-provider","title":"KCP Provider","text":"<p>When using the KCP provider (<code>--multicluster-runtime-provider kcp</code>), the backend:</p> <ul> <li>Connects to kcp workspaces through APIExports</li> <li>Manages resources across logical clusters  </li> <li>Supports advanced multi-tenancy features</li> <li>Enables workspace-based isolation</li> </ul>"},{"location":"developers/backend/#default-provider","title":"Default Provider","text":"<p>The default provider works with standard Kubernetes clusters and provides:</p> <ul> <li>Direct cluster connectivity</li> <li>Namespace-based isolation</li> <li>Standard RBAC integration</li> </ul>"},{"location":"developers/backend/#api-changes","title":"API Changes","text":"<p>The backend now supports the v1alpha2 API with significant architectural improvements:</p> <ul> <li>Resource-Based Exports: APIServiceExport now uses resource references instead of embedded CRDs</li> <li>BoundSchema Support: Integration with BoundSchema resources for better schema management</li> <li>Multi-Resource Support: Single exports can reference multiple CRDs efficiently</li> </ul>"},{"location":"developers/backend/#controllers","title":"Controllers","text":"<p>The backend includes several controllers for managing the export/binding lifecycle:</p> <ul> <li>ClusterBinding Controller: Manages cluster binding lifecycle</li> <li>ServiceExport Controller: Handles APIServiceExport resources</li> <li>ServiceExportRequest Controller: Processes export requests</li> <li>ServiceNamespace Controller: Manages namespace isolation</li> </ul>"},{"location":"developers/backend/http/api-binding/","title":"API Binding","text":""},{"location":"developers/backend/http/api-binding/#overview","title":"Overview","text":"<pre><code>sequenceDiagram\n    autonumber\n    participant consumer-cluster as Consumer cluster\n    participant client as Client\n    participant provider-cluster as Provider cluster\n    participant provider-backend as Provider backend\n\n\n    %% Create APIServiceExportRequest\n    client-&gt;&gt;provider-cluster: Create \"APIServiceExportRequest\"\n\n    par Provider\n      provider-backend-&gt;&gt;provider-cluster: Get \"APIServiceExportRequest\"\n      loop For each \"APIServiceExportRequest.spec.resources\"\n        provider-backend-&gt;&gt;provider-cluster: Create \"APIServiceExport\"\n      end\n      provider-backend-&gt;&gt;provider-cluster: Set \"APIServiceExportRequest.status.phase\"\n    and Client\n      loop Every 1 second for 10 minutes\n      client-&gt;&gt;provider-cluster: Get \"APIServiceExportRequest\"\n      client-&gt;&gt;client: Verify \"APIServiceExportRequest\"&lt;br/&gt;(.status.phase == Succeeded)\"\n      end\n    end\n\n    %% Create APIServiceBindings\n    loop For each \"APIServiceExportRequest.spec.resources\"\n    client-&gt;&gt;consumer-cluster: Create \"APIServiceBinding\"\n    end</code></pre>"},{"location":"developers/backend/http/api-binding/#contracts","title":"Contracts","text":"<p>APIServiceExportRequest</p> <p>In case the APIServiceExportRequest is accepted, the provider backend must ensure that</p> <ul> <li>for each <code>APIServiceExportRequest.spec.resources</code> an <code>APIServiceExport</code> is created</li> <li>each <code>APIServiceExport</code> is created in the namespace of the <code>APIServiceExportRequest</code></li> <li>each <code>APIServiceExport</code> is created with a name following the pattern <code>resource.resource + \".\" + resource.group</code></li> <li>the <code>APIServiceExportRequest.status.phase</code> is set to <code>Succeeded</code></li> </ul> <p>In case the APIServiceExportRequest is declined, the provider backend must ensure that</p> <ul> <li>the <code>APIServiceExportRequest.status.terminalMessage</code> is set to a human readable message describing the reason</li> <li>the <code>APIServiceExportRequest.status.phase</code> is set to <code>Failed</code></li> </ul>"},{"location":"developers/backend/http/cluster-binding/","title":"Cluster Binding","text":""},{"location":"developers/backend/http/cluster-binding/#overview","title":"Overview","text":"<pre><code>sequenceDiagram\n    autonumber\n    participant consumer-cluster as Consumer cluster\n    participant client as Client\n    participant provider-backend as Provider backend\n    participant authentication-provider as Authentication Provider\n\n    %% Get provider information\n    client-&gt;&gt;+provider-backend: GET \"${PROVIDER_BINDING_URL}\"\n    provider-backend-&gt;&gt;-client: 200 \"BindingProvider\"\n\n    client-&gt;&gt;client: Verify \"BindingProvider\"\n\n    %% Authenticate to provider\n    client--&gt;&gt;authentication-provider: Authenticate to provider\n\n    %% Bind to API\n    provider-backend-&gt;&gt;client: 200 \"BindingResponse\"\n\n    client-&gt;&gt;consumer-cluster: Ensure kubeconfig secret\n\n    loop For each \"BindingResponse.requests\"\n    client-&gt;&gt;consumer-cluster: Bind remote API to consumer cluster\n    end</code></pre>"},{"location":"developers/backend/http/cluster-binding/#contracts","title":"Contracts","text":"<p>BindingResponse</p> <p>In case the cluster binding request is accepted, the provider backend must ensure that</p> <ul> <li>the kubeconfig returned in the <code>BindingResponse</code> contains a current context</li> <li>the configured current context points to the \"cluster namespace\"</li> <li>the <code>ClusterBinding</code> object named \"cluster\" exists in the \"cluster namespace\"</li> <li>the secret referenced by <code>ClusterBinding.spec.kubeconfigSecretRef.name</code> exists</li> <li>the key of the secret referenced by <code>ClusterBinding.spec.kubeconfigSecretRef.key</code> contains a valid kubeconfig</li> <li>the configured current context points to a user with at least the following permissions in the \"cluster namespace\" (here expressed as RBAC rules)   <pre><code>- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiserviceexportrequests\"]\n  verbs: [\"create\", \"delete\", \"patch\", \"update\", \"get\", \"list\", \"watch\"]\n\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiserviceexports\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiserviceexports/status\"]\n  verbs: [\"get\", \"patch\", \"update\"]\n\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiservicenamespaces\"]\n  verbs: [\"create\", \"delete\", \"patch\", \"update\", \"get\", \"list\", \"watch\"]\n\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"clusterbindings\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"clusterbindings/status\"]\n  verbs: [\"get\", \"patch\", \"update\"]\n\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre></li> </ul>"},{"location":"developers/konnector/","title":"konnector","text":""},{"location":"developers/konnector/controllers/apiservicebinding/","title":"APIServiceBindings","text":"<p>The APIServiceBinding controller watches <code>APIServiceBindings</code> and the referenced <code>Secrets</code> in the consumer cluster.</p> <p>It is responsible for:</p> <ul> <li>validating the kubeconfig stored in the secrets referenced by <code>APIServiceBindings</code></li> </ul>"},{"location":"developers/konnector/controllers/apiservicebinding/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceBinding\"])\n\n    get_kubeconfig_secret([\"Get referenced kubeconfig secret\"])\n    is_kubeconfig_valid{\"kubeconfig&lt;br&gt;valid?\"}\n\n    set_condition_secret_valid_to_true([\"Set condition 'SecretValid' to true\"])\n    set_condition_secret_valid_to_false([\"Set condition 'SecretValid' to false\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_kubeconfig_secret\n    get_kubeconfig_secret --&gt; is_kubeconfig_valid\n\n    is_kubeconfig_valid --&gt; |yes| set_condition_secret_valid_to_true\n    is_kubeconfig_valid --&gt; |no| set_condition_secret_valid_to_false\n\n    set_condition_secret_valid_to_true --&gt; stop\n    set_condition_secret_valid_to_false --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/konnector/","title":"konnector","text":"<p>The konnector implements the main reconciliation loop and watches <code>APIServiceBindings</code> and the referenced <code>Secrets</code> in the consumer cluster.</p> <p>It is responsible for:</p> <ul> <li>starting / stopping a set of controllers per service provider</li> </ul>"},{"location":"developers/konnector/controllers/konnector/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceBinding\"])\n\n    get_kubeconfig_secret([\"Get referenced kubeconfig secret\"])\n    is_kubeconfig_empty{\"kubeconfig&lt;br&gt;empty?\"}\n\n    get_controller_context_for_binding([\"Get controller context for binding\"])\n    is_controller_context_for_binding_present{\"context&lt;br&gt;exists?\"}\n    is_controller_context_current{\"context&lt;br&gt;up-to-date?\"}\n    is_controller_context_used{\"context&lt;br&gt;in use?\"}\n\n    get_controller_context_for_kubeconfig([\"Get controller context for kubeconfig\"])\n    is_controller_context_for_kubeconfig_present{\"context&lt;br&gt;exists?\"}\n\n    create_controller_context_for_binding([\"Create controller context for binding\"])\n    add_binding_to_controller_context([\"Add binding to controller context\"])\n    remove_binding_from_controller_context([\"Remove binding from controller context\"])\n\n    start_controllers([\"Start controllers\"])\n    stop_controllers([\"Stop controllers\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_kubeconfig_secret\n    get_kubeconfig_secret --&gt; get_controller_context_for_binding\n    get_controller_context_for_binding --&gt; is_controller_context_for_binding_present\n\n    is_controller_context_for_binding_present --&gt;|yes| is_controller_context_current\n        is_controller_context_current --&gt;|yes| is_kubeconfig_empty\n        is_controller_context_current --&gt;|no| remove_binding_from_controller_context\n            remove_binding_from_controller_context --&gt; is_controller_context_used\n                is_controller_context_used --&gt;|yes| stop\n                is_controller_context_used --&gt;|no| stop_controllers\n                    stop_controllers --&gt; stop\n\n    is_controller_context_for_binding_present --&gt;|no| is_kubeconfig_empty\n        is_kubeconfig_empty --&gt;|yes| stop\n        is_kubeconfig_empty --&gt;|no| get_controller_context_for_kubeconfig\n            get_controller_context_for_kubeconfig --&gt; is_controller_context_for_kubeconfig_present\n            is_controller_context_for_kubeconfig_present --&gt;|yes| add_binding_to_controller_context\n                add_binding_to_controller_context --&gt; stop\n            is_controller_context_for_kubeconfig_present --&gt;|no| create_controller_context_for_binding\n                create_controller_context_for_binding --&gt; start_controllers\n                start_controllers --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/apiservicebinding/","title":"APIServiceBindings","text":"<p>The APIServiceBinding controller watches <code>APIServiceBindings</code>, and <code>CRDs</code> in the consumer cluster and <code>APIServiceExports</code> in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>synchronizing <code>APIServiceExports</code> in the provider cluster to <code>CRDs</code> in the consumer cluster</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiservicebinding/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call\n    for APIServiceBinding\"])\n\n    is_apiservicebinding_owned{\"binding&lt;br&gt;owned?\"}\n    set_apiservicebinding_condition_connected_to_true([\"Set condition\n    'Connected'\n    to true\"])\n    set_apiservicebinding_condition_connected_to_true2([\"Set condition 'Connected'\n    to true\"])\n\n    set_apiservicebinding_condition_connected_to_false([\"Set condition 'Connected'\n    to false\"])\n    set_apiservicebinding_condition_connected_to_false2([\"Set condition 'Connected'\n    to false\"])\n\n    set_apiservicebinding_condition_schemainsync_to_true([\"Set condition 'SchemaInSync'\n    to true\"])\n\n    get_apiserviceexport([\"Get provider\n    APIServiceExport\"])\n    is_apiserviceexport_present{\"export&lt;br&gt;exists?\"}\n\n    get_apiserviceexportrequest([\"Get provider\n     APIServiceExportRequest\"])\n    is_apiserviceexportrequest_in_failed_state{\"Is APIServiceExportRequest&lt;br&gt;in failed state?\"}\n\n    get_bound_schemas([\"Get provider\n    BoundSchemas referenced in\n    APIServiceExport\"])\n    bound_schema_fetch_successful([\"Fetching BoundSchemas\n    succeed?\"])\n    reference_bound_schema([\"Reference BoundSchema\n    in APIServiceBinding\n    status\"])\n    convert_boundschema_to_crd([\"Convert BoundSchema\n    to CRD\"])\n\n\n    get_crd([\"Get CRD\"])\n    create_crd([\"Create CRD\"])\n    update_crd([\"Update CRD\"])\n    is_crd_present{\"CRD&lt;br&gt;exists?\"}\n    is_crd_owned{\"CRD&lt;br&gt;owned?\"}\n\n    get_clusterbinding([\"Get ClusterBinding\"])\n    set_apiservicebinding_provider_name([\"Set provider name\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; is_apiservicebinding_owned\n\n    is_apiservicebinding_owned --&gt; |yes| get_apiserviceexport\n    get_apiserviceexport --&gt; is_apiserviceexport_present\n    is_apiserviceexport_present --&gt; |yes| set_apiservicebinding_condition_connected_to_true2\n    is_apiserviceexport_present --&gt; |no| get_apiserviceexportrequest\n    get_apiserviceexportrequest --&gt; is_apiserviceexportrequest_in_failed_state\n    is_apiserviceexportrequest_in_failed_state --&gt; |yes| set_apiservicebinding_condition_connected_to_false2\n    is_apiserviceexportrequest_in_failed_state --&gt; |no| set_apiservicebinding_condition_connected_to_false2\n\n    set_apiservicebinding_condition_connected_to_false2 --&gt; stop\n    set_apiservicebinding_condition_connected_to_true2 --&gt; get_bound_schemas\n    get_bound_schemas --&gt; bound_schema_fetch_successful\n    bound_schema_fetch_successful --&gt; |yes| reference_bound_schema\n    bound_schema_fetch_successful --&gt; |no| set_apiservicebinding_condition_connected_to_false\n    reference_bound_schema --&gt; convert_boundschema_to_crd\n    set_apiservicebinding_condition_connected_to_false --&gt; stop\n\n    convert_boundschema_to_crd --&gt;  get_crd\n\n    get_crd --&gt; is_crd_present\n    is_crd_present --&gt; |no| create_crd\n    is_crd_present --&gt; |yes| is_crd_owned\n    create_crd --&gt; update_crd\n\n    update_crd --&gt; set_apiservicebinding_condition_connected_to_true\n    set_apiservicebinding_condition_connected_to_true --&gt; set_apiservicebinding_condition_schemainsync_to_true\n\n    is_crd_owned --&gt; |yes| update_crd\n    is_crd_owned --&gt; |no| set_apiservicebinding_condition_connected_to_false\n\n    set_apiservicebinding_condition_schemainsync_to_true --&gt; get_clusterbinding\n    get_clusterbinding --&gt; set_apiservicebinding_provider_name\n    is_apiservicebinding_owned --&gt; |no| stop\n    set_apiservicebinding_provider_name --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/apiserviceexport/","title":"APIServiceExports","text":"<p>The APIServiceExport controller watches <code>APIServiceExports</code> and the referenced resources in the provider cluster.</p> <p>Starting with v1alpha2, the APIServiceExport has been refactored to use a resource-based model instead of embedded CRD specifications.</p>"},{"location":"developers/konnector/controllers/cluster/apiserviceexport/#key-changes-in-v1alpha2","title":"Key Changes in v1alpha2","text":"<ul> <li>Resource-Based Model: <code>APIServiceExportSpec</code> now uses <code>Resources []APIServiceExportResource</code> instead of embedded CRD specs</li> <li>Multi-Resource Support: One APIServiceExport can reference multiple CRDs more efficiently</li> <li>BoundSchema Integration: Works with the new <code>BoundSchema</code> resource type for tracking bound schemas in consumer clusters</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiserviceexport/#controller-responsibilities","title":"Controller Responsibilities","text":"<ul> <li>Ensuring the existence and validity of <code>APIServiceExports</code>.</li> <li>Managing the lifecycle of <code>APIServiceExports</code> by starting and stopping spec and status syncers and controllers.</li> <li>Checking <code>APIServiceBinding</code> condition and setting <code>ConsumerInSync</code> condition in <code>APIServiceExport</code></li> <li>Managing resource references and their associated schemas.</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiserviceexport/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call\n    for APIServiceExport\"])\n    is_apiserviceexport_present{\"APIServiceExport&lt;br&gt;exists?\"}\n\n    get_bound_schemas([\"Get referenced\n    BoundSchemas\"])\n    get_bound_schemas2([\"Get referenced\n    BoundSchemas\"])\n    is_bound_schema_present{\"BoundSchema&lt;br&gt;exists?\"}\n    update_bound_schema([\"Update BoundSchema\n    status\"])\n\n    stop_apiserviceexport_sync([\"Stop APIServiceExport sync\"])\n\n    get_binding([\"Get referenced\n    APIServiceBinding\"])\n    get_binding2([\"Get referenced\n    APIServiceBinding\"])\n\n    is_binding_present{\"APIServiceBinding&lt;br&gt;exists?\"}\n    is_binding_present2{\"APIServiceBinding&lt;br&gt;exists?\"}\n\n    is_binding_schemainsync{\"APIServiceBinding&lt;br&gt;has SchemaInSync?\"}\n    start_new_syncer([\"Start new syncer\"])\n\n    set_apiserviceexport_condition_connected_to_true([\"Set condition\n    'Connected' to true\"])\n    set_apiserviceexport_condition_connected_to_false([\"Set\n    condition 'Connected'\nto false\"])\n    set_apiserviceexport_condition_consumerinsync_to_true([\"Set condition\n    'ConsumerInSync' to true\"])\n    set_apiserviceexport_condition_consumerinsync_to_false([\"Set condition\n    'ConsumerInSync' to false\"])\n\n    get_crd([\"Get referenced\n    CustomResourceDefinition\"])\n    copy_crd_conditions([\"Copy CRD conditions\n    to APIServiceExport\n    conditions\"])\n    set_summary_condition([\"Set summary\n    of all conditions\n    on APIServiceExport\"])\n\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; is_apiserviceexport_present\n    is_apiserviceexport_present --&gt; |no| stop\n    is_apiserviceexport_present --&gt; |yes| get_binding\n\n    get_binding --&gt; is_binding_present\n    is_binding_present --&gt; |yes| get_bound_schemas\n    is_binding_present --&gt; |no| stop_apiserviceexport_sync\n    stop_apiserviceexport_sync --&gt; stop\n\n    get_bound_schemas --&gt; is_bound_schema_present\n    is_bound_schema_present --&gt; |yes| start_new_syncer\n    is_bound_schema_present --&gt; |no| stop_apiserviceexport_sync\n    stop_apiserviceexport_sync --&gt; stop\n\n    start_new_syncer --&gt; get_binding2\n    get_binding2 --&gt; is_binding_present2\n    is_binding_present2 --&gt; |yes| set_apiserviceexport_condition_connected_to_true\n    is_binding_present2 --&gt; |no| set_apiserviceexport_condition_connected_to_false\n    set_apiserviceexport_condition_connected_to_false --&gt; set_apiserviceexport_condition_consumerinsync_to_false\n    set_apiserviceexport_condition_connected_to_true --&gt; is_binding_schemainsync\n    is_binding_schemainsync --&gt; |yes| set_apiserviceexport_condition_consumerinsync_to_true\n    set_apiserviceexport_condition_consumerinsync_to_true --&gt; get_bound_schemas2\n    is_binding_schemainsync --&gt; |no| set_apiserviceexport_condition_consumerinsync_to_false\n    set_apiserviceexport_condition_consumerinsync_to_false --&gt; get_bound_schemas2\n\n    get_bound_schemas2 --&gt; get_crd\n    get_crd --&gt; copy_crd_conditions\n    copy_crd_conditions --&gt; set_summary_condition\n    set_summary_condition --&gt; update_bound_schema\n    update_bound_schema --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/apiservicenamespace/","title":"APIServiceNamespaces","text":"<p>The APIServiceNamespace controller watches <code>Namespaces</code> in the consumer cluster and <code>APIServiceNamespaces</code> in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>synchronizing <code>Namespaces</code> in the consumer cluster with <code>APIServiceNamespaces</code> in the provider cluster</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiservicenamespace/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceNamespace\"])\n\n    get_namespace([\"Get associated namespace\"])\n    is_namespace_present([\"namespace&lt;br&gt;exists?\"])\n\n    delete_api_service_namespace([\"Delete APIServiceNamespace\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_namespace\n    get_namespace --&gt; is_namespace_present\n\n    is_namespace_present --&gt; |yes| stop\n    is_namespace_present --&gt; |no| delete_api_service_namespace\n    delete_api_service_namespace --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/boundschema/","title":"BoundSchema","text":"<p>The BoundSchema controller manages <code>BoundSchema</code> resources in the consumer cluster, introduced in v1alpha2.</p> <p><code>BoundSchema</code> represents bound API resource schemas in consumer clusters and tracks the underlying status of synced resources.</p>"},{"location":"developers/konnector/controllers/cluster/boundschema/#key-features","title":"Key Features","text":"<ul> <li>Schema Validation: Ensures the bound schema is valid and properly applied</li> <li>Drift Detection: Monitors for differences between expected and actual schema state  </li> <li>Condition Management: Provides status conditions for validation and drift detection</li> </ul>"},{"location":"developers/konnector/controllers/cluster/boundschema/#boundschema-structure","title":"BoundSchema Structure","text":"<pre><code>apiVersion: kube-bind.io/v1alpha2\nkind: BoundSchema\nmetadata:\n  labels:\n    kube-bind.io/exported: \"true\"\n  name: cowboys.wildwest.dev\n  namespace: kube-bind-flsd8\nspec:\n  group: wildwest.dev\n  informerScope: Namespaced\n  names:\n    kind: Cowboy\n    listKind: CowboyList\n    plural: cowboys\n    singular: cowboy\n  scope: Namespaced\n  versions: ...\n</code></pre>"},{"location":"developers/konnector/controllers/cluster/boundschema/#integration-with-apiserviceexport","title":"Integration with APIServiceExport","text":"<p>BoundSchema works closely with the APIServiceExport resource-based model:</p> <ol> <li>APIServiceExport references multiple resources via <code>Resources []APIServiceExportResource</code></li> <li>Each resource can map to a BoundSchema in the consumer cluster</li> <li>BoundSchema tracks the actual application and status of these schemas</li> <li>This enables better multi-resource management and status tracking</li> </ol>"},{"location":"developers/konnector/controllers/cluster/clusterbinding/","title":"ClusterBindings","text":"<p>The ClusterBinding controller watches <code>Secrets</code> (referenced by <code>APIServiceBindings</code>) in the consumer cluster and <code>ClusterBindings</code>, the referenced <code>Secrets</code>, and <code>APIServiceExport</code> in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>synchronizing the secret referenced by the <code>ClusterBinding</code> in the provider cluster to the secret referenced by the <code>APIServiceBindings</code> in the consumer cluster</li> <li>reporting heartbeat to <code>ClusterBinding</code> in the provider cluster</li> <li>reporting konnector version <code>ClusterBinding</code> in the provider cluster</li> <li>reporting heartbeat to all <code>APIServiceBindings</code> managed by <code>ClusterBinding</code> in the consumer cluster</li> </ul>"},{"location":"developers/konnector/controllers/cluster/clusterbinding/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for ClusterBinding\"])\n\n    update_cluster_binding([\"Update ClusterBinding\"])\n    is_cluster_binding_update_successful{\"update&lt;br&gt;successful?\"}\n\n    get_cluster_binding_kubeconfig_secret([\"Get referenced provider kubeconfig secret\"])\n    is_cluster_binding_kubeconfig_secret_valid{\"secret&lt;br&gt;valid?\"}\n\n    set_cluster_binding_condition_secret_valid_to_true([\"Set condition 'SecretValid' to true\"])\n    set_cluster_binding_condition_secret_valid_to_false([\"Set condition 'SecretValid' to false\"])\n    set_cluster_binding_condition_valid_version_to_true([\"Set condition 'ValidVersion' to true\"])\n    set_cluster_binding_condition_valid_version_to_false([\"Set condition 'ValidVersion' to false\"])\n    set_cluster_binding_condition_ready([\"Set condition 'Ready' to summary\"])\n\n    set_cluster_binding_status_last_heartbeat([\"Set status 'LastHeartbeatTime' to now\"])\n    set_cluster_binding_status_konnector_version([\"Set status 'KonnectorVersion'\"])\n\n    get_api_binding_kubeconfig_secret([\"Get consumer kubeconfig secret\"])\n    create_api_binding_kubeconfig_secret([\"Create consumer kubeconfig secret\"])\n    update_api_binding_kubeconfig_secret([\"Update consumer kubeconfig secret\"])\n    is_api_binding_kubeconfig_secret_present{\"secret&lt;br&gt;exists?\"}\n\n    set_api_binding_status_heartbeating_to_true([\"Set APIServiceBinding conditions 'Heartbeating' to true\"])\n    set_api_binding_status_heartbeating_to_false([\"Set APIServiceBinding conditions 'Heartbeating' to false\"])\n\n    get_konnector_version([\"Get konnector version\"])\n    is_konnector_version_valid{\"version&lt;br&gt;valid?\"}\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_cluster_binding_kubeconfig_secret\n    get_cluster_binding_kubeconfig_secret --&gt; is_cluster_binding_kubeconfig_secret_valid\n\n    is_cluster_binding_kubeconfig_secret_valid --&gt; |yes| get_api_binding_kubeconfig_secret\n        get_api_binding_kubeconfig_secret --&gt; is_api_binding_kubeconfig_secret_present\n        is_api_binding_kubeconfig_secret_present --&gt; |yes| update_api_binding_kubeconfig_secret\n        is_api_binding_kubeconfig_secret_present --&gt; |no| create_api_binding_kubeconfig_secret\n        update_api_binding_kubeconfig_secret --&gt; set_cluster_binding_condition_secret_valid_to_true\n        create_api_binding_kubeconfig_secret --&gt; set_cluster_binding_condition_secret_valid_to_true\n\n    is_cluster_binding_kubeconfig_secret_valid --&gt; |no| set_cluster_binding_condition_secret_valid_to_false\n\n    set_cluster_binding_condition_secret_valid_to_true --&gt; set_cluster_binding_status_last_heartbeat\n    set_cluster_binding_condition_secret_valid_to_false --&gt; set_cluster_binding_status_last_heartbeat\n\n    set_cluster_binding_status_last_heartbeat --&gt; get_konnector_version\n    get_konnector_version --&gt; is_konnector_version_valid\n\n    is_konnector_version_valid --&gt; |yes| set_cluster_binding_status_konnector_version\n        set_cluster_binding_status_konnector_version --&gt; set_cluster_binding_condition_valid_version_to_true\n\n    is_konnector_version_valid --&gt; |no| set_cluster_binding_condition_valid_version_to_false\n\n    set_cluster_binding_condition_valid_version_to_true --&gt; set_cluster_binding_condition_ready\n    set_cluster_binding_condition_valid_version_to_false --&gt; set_cluster_binding_condition_ready\n\n    set_cluster_binding_condition_ready --&gt; update_cluster_binding\n    update_cluster_binding --&gt; is_cluster_binding_update_successful\n\n    is_cluster_binding_update_successful --&gt; |yes| set_api_binding_status_heartbeating_to_true\n    is_cluster_binding_update_successful --&gt; |no| set_api_binding_status_heartbeating_to_false\n\n    set_api_binding_status_heartbeating_to_true --&gt; stop\n    set_api_binding_status_heartbeating_to_false --&gt; stop</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>This chapter provides automatically generated references for the kube-bind <code>kubectl</code> plugin and APIs included in kube-bind.</p>"},{"location":"reference/cli/bind/","title":"bind","text":""},{"location":"reference/cli/bind/#synopsis","title":"Synopsis","text":"<p>kube-bind is a project that aims to provide better support for service providers and consumers that reside in distinct Kubernetes clusters.</p> <p>For more information, see: https://kube-bind.io</p> <p>To bind a remote service, use the 'kubectl bind' command. Please check the examples below for more information.</p> <pre><code>bind [flags]\n</code></pre>"},{"location":"reference/cli/bind/#examples","title":"Examples","text":"<pre><code>    # select a kube-bind.io compatible service from the given URL, e.g. an API service.\n    kubectl bind https://mangodb.com/exports\n\n    # authenticate and configure the services to bind, but don't actually bind them.\n    kubectl bind https://mangodb.com/exports --dry-run -o yaml &gt; apiservice-export-requests.yaml\n\n    # bind to a remote API service as configured above and actually bind to it, e.g. in GitOps automation.\n    kubectl bind apiservice --remote-kubeconfig name -f apiservice-binding-requests.yaml\n\n    # bind to a remote API service via a request manifest from a https URL.\n    kubectl bind apiservice --remote-kubeconfig name https://some-url.com/apiservice-export-requests.yaml\n</code></pre>"},{"location":"reference/cli/bind/#options","title":"Options","text":"<pre><code>      --add_dir_header                       If true, adds the file directory to the header of the log messages\n      --allow-missing-template-keys          If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats. (default true)\n      --alsologtostderr                      log to standard error as well as files (no effect when -logtostderr=true)\n      --as-uid string                        UID to impersonate for the operation\n      --certificate-authority string         Path to a cert file for the certificate authority\n      --context string                       The name of the kubeconfig context to use\n      --disable-compression                  If true, opt-out of response compression for all requests to the server\n  -d, --dry-run                              If true, only print the requests that would be sent to the service provider after authentication, without actually binding.\n  -h, --help                                 help for bind\n      --insecure-skip-tls-verify             Skip the verification of the server's certificate chain and host name.\n      --konnector-image string               The konnector image to use\n      --kubeconfig string                    path to the kubeconfig file\n      --log-flush-frequency duration         Maximum number of seconds between log flushes (default 5s)\n      --log-text-info-buffer-size quantity   [Alpha] In text format with split output streams, the info messages can be buffered for a while to increase performance. The default value of zero bytes disables buffering. The size can be specified as number of bytes (512), multiples of 1000 (1K), multiples of 1024 (2Ki), or powers of those (3M, 4G, 5Mi, 6Gi). Enable the LoggingAlphaOptions feature gate to use this.\n      --log-text-split-stream                [Alpha] In text format, write error messages to stderr and info messages to stdout. The default is to write a single stream to stdout. Enable the LoggingAlphaOptions feature gate to use this.\n      --log_backtrace_at traceLocation       when logging hits line file:N, emit a stack trace (default :0)\n      --log_dir string                       If non-empty, write log files in this directory (no effect when -logtostderr=true)\n      --log_file string                      If non-empty, use this log file (no effect when -logtostderr=true)\n      --log_file_max_size uint               Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800)\n      --logging-format string                Sets the log format. Permitted formats: \"text\". (default \"text\")\n      --logtostderr                          log to standard error instead of files (default true)\n  -n, --namespace string                     If present, the namespace scope for this CLI request\n      --one_output                           If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true)\n  -o, --output string                        Output format. One of: (json, yaml, name, go-template, go-template-file, template, templatefile, jsonpath, jsonpath-as-json, jsonpath-file). (default \"yaml\")\n      --password string                      Password for basic authentication to the API server\n      --proxy-url string                     If provided, this URL will be used to connect via proxy\n      --server string                        The address and port of the Kubernetes API server\n      --show-managed-fields                  If true, keep the managedFields when printing objects in JSON or YAML format.\n      --skip-konnector                       Skip the deployment of the konnector\n      --skip_headers                         If true, avoid header prefixes in the log messages\n      --skip_log_headers                     If true, avoid headers when opening log files (no effect when -logtostderr=true)\n      --stderrthreshold severity             logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=true) (default 2)\n      --template string                      Template string or path to template file to use when -o=go-template, -o=go-template-file. The template format is golang templates [http://golang.org/pkg/text/template/#pkg-overview].\n      --tls-server-name string               If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                         Bearer token for authentication to the API server\n      --user string                          The name of the kubeconfig user to use\n      --username string                      Username for basic authentication to the API server\n  -v, --v Level                              number for the log level verbosity\n      --vmodule pattern=N,...                comma-separated list of pattern=N settings for file-filtered logging (only works for text log format)\n</code></pre>"},{"location":"reference/cli/bind/#see-also","title":"SEE ALSO","text":"<ul> <li>bind apiservice    - Bind to a remote API service</li> </ul>"},{"location":"reference/cli/bind_apiservice/","title":"bind apiservice","text":"<pre><code>bind apiservice https://&lt;url-to-a-APIServiceExportRequest&gt;|-f &lt;file-to-a-APIBindingRequest&gt; [flags]\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#examples","title":"Examples","text":"<pre><code>    # bind to a remote API service. Use kubectl bind to create the APIServiceExportRequest interactively.\n    kubectl bind apiservice --remote-kubeconfig file -f apiservice-export-request.yaml\n\n    # bind to a remote API service via a request manifest from a https URL.\n    kubectl bind apiservice --remote-kubeconfig file https://some-url.com/apiservice-export-requests.yaml\n\n    # bind to a API service directly without any remote agent or service provider.\n    kubectl bind apiservice --remote-kubeconfig file -n remote-namespace resources.group/v1\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#options","title":"Options","text":"<pre><code>      --allow-missing-template-keys          If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats. (default true)\n      --as-uid string                        UID to impersonate for the operation\n      --certificate-authority string         Path to a cert file for the certificate authority\n      --context string                       The name of the kubeconfig context to use\n      --disable-compression                  If true, opt-out of response compression for all requests to the server\n      --downgrade-konnector                  Downgrade the konnector to the version of the kubectl-bind-apiservice binary\n  -f, --file string                          A file with an APIServiceExportRequest manifest. Use - to read from stdin\n  -h, --help                                 help for apiservice\n      --insecure-skip-tls-verify             If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                    path to the kubeconfig file\n      --log-flush-frequency duration         Maximum number of seconds between log flushes (default 5s)\n      --log-text-info-buffer-size quantity   [Alpha] In text format with split output streams, the info messages can be buffered for a while to increase performance. The default value of zero bytes disables buffering. The size can be specified as number of bytes (512), multiples of 1000 (1K), multiples of 1024 (2Ki), or powers of those (3M, 4G, 5Mi, 6Gi). Enable the LoggingAlphaOptions feature gate to use this.\n      --log-text-split-stream                [Alpha] In text format, write error messages to stderr and info messages to stdout. The default is to write a single stream to stdout. Enable the LoggingAlphaOptions feature gate to use this.\n      --logging-format string                Sets the log format. Permitted formats: \"text\". (default \"text\")\n  -n, --namespace string                     If present, the namespace scope for this CLI request\n  -o, --output string                        Output format. One of: (json, yaml, name, go-template, go-template-file, template, templatefile, jsonpath, jsonpath-as-json, jsonpath-file).\n      --password string                      Password for basic authentication to the API server\n      --proxy-url string                     If provided, this URL will be used to connect via proxy\n      --remote-kubeconfig string             A file path for a kubeconfig file to connect to the service provider cluster\n      --remote-kubeconfig-name string        The name of the remote kubeconfig secret to read from\n      --remote-kubeconfig-namespace string   The namespace of the remote kubeconfig secret to read from\n      --remote-namespace string              The namespace in the remote cluster where the konnector is deployed\n      --server string                        The address and port of the Kubernetes API server\n      --show-managed-fields                  If true, keep the managedFields when printing objects in JSON or YAML format.\n      --skip-konnector                       Skip the deployment of the konnector\n      --template string                      Template string or path to template file to use when -o=go-template, -o=go-template-file. The template format is golang templates [http://golang.org/pkg/text/template/#pkg-overview].\n      --tls-server-name string               If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                         Bearer token for authentication to the API server\n      --user string                          The name of the kubeconfig user to use\n      --username string                      Username for basic authentication to the API server\n  -v, --v Level                              number for the log level verbosity\n      --vmodule pattern=N,...                comma-separated list of pattern=N settings for file-filtered logging (only works for text log format)\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --add_dir_header                   If true, adds the file directory to the header of the log messages\n      --alsologtostderr                  log to standard error as well as files (no effect when -logtostderr=true)\n      --log_backtrace_at traceLocation   when logging hits line file:N, emit a stack trace (default :0)\n      --log_dir string                   If non-empty, write log files in this directory (no effect when -logtostderr=true)\n      --log_file string                  If non-empty, use this log file (no effect when -logtostderr=true)\n      --log_file_max_size uint           Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800)\n      --logtostderr                      log to standard error instead of files (default true)\n      --one_output                       If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true)\n      --skip_headers                     If true, avoid header prefixes in the log messages\n      --skip_log_headers                 If true, avoid headers when opening log files (no effect when -logtostderr=true)\n      --stderrthreshold severity         logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=true) (default 2)\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#see-also","title":"SEE ALSO","text":"<ul> <li>bind  - kubectl plugin for Kube-Bind.io, bind different remote types into the current cluster.</li> </ul>"},{"location":"reference/crd/kube-bind.io/apiservicebindings/","title":"APIServiceBinding","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#apiservicebinding-crd-schema-reference-group-kube-bindio","title":"APIServiceBinding CRD schema reference (group kube-bind.io)","text":"APIServiceBinding binds an API service represented by a APIServiceExport in a service provider cluster into a consumer cluster. This object lives in the consumer cluster.  Full name: apiservicebindings.kube-bind.io Group: kube-bind.io Singular name: apiservicebinding Plural name: apiservicebindings Scope: Cluster Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>Namespace of the referent.</p> object <p>status contains reconciliation information for a service binding.</p> array <p>conditions is a list of conditions that apply to the APIServiceBinding.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different APIServiceBindings.</p>"},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef.namespace","title":".spec.kubeconfigSecretRef.namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.providerPrettyName","title":".status.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>Namespace of the referent.</p> object <p>status contains reconciliation information for a service binding.</p> array <p>BoundSchemas contains references to all BoundAPIResourceSchema objects associated with this APIServiceBinding, tracking consumer usage status.</p> object <p>BoundSchemaReference contains a reference to a BoundAPIResourceSchema with status information.</p> string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>conditions is a list of conditions that apply to the APIServiceBinding.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> array <p>PermissionClaims records decisions about permission claims requested by the service provider. Access is granted per GroupResource.</p> object <p>PermissionClaim selects objects of a GVR that a service provider may request and that a consumer may accept and allow the service provider access to.</p> string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> object Required <p>Selector is a resource selector that selects objects of a GVR.</p> object <p>LabelSelector is a label selector that selects objects of a GVR.</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> array <p>NamedResource is a shorthand for selecting a single resource by name and namespace.</p> object <p>NamedResource selects a specific resource by name and namespace.</p> string Required <p>Name is the name of the resource. Name matches the metadata.name field of the underlying object.</p> string <p>Namespace represents namespace where an object of the given group/resource may be managed. Namespaces matches against the metadata.namespace field. If not provided, the object is assumed to be cluster-scoped. Namespaces field is ignored for namespaced isolation mode.</p> string <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different APIServiceBindings.</p>"},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef.namespace","title":".spec.kubeconfigSecretRef.namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas","title":".status.boundSchemas","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas[*]","title":".status.boundSchemas[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas[*].group","title":".status.boundSchemas[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas[*].resource","title":".status.boundSchemas[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims","title":".status.permissionClaims","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*]","title":".status.permissionClaims[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].group","title":".status.permissionClaims[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].resource","title":".status.permissionClaims[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector","title":".status.permissionClaims[*].selector","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector","title":".status.permissionClaims[*].selector.labelSelector","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchExpressions","title":".status.permissionClaims[*].selector.labelSelector.matchExpressions","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchExpressions[*]","title":".status.permissionClaims[*].selector.labelSelector.matchExpressions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchExpressions[*].key","title":".status.permissionClaims[*].selector.labelSelector.matchExpressions[*].key","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchExpressions[*].operator","title":".status.permissionClaims[*].selector.labelSelector.matchExpressions[*].operator","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchExpressions[*].values","title":".status.permissionClaims[*].selector.labelSelector.matchExpressions[*].values","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchExpressions[*].values[*]","title":".status.permissionClaims[*].selector.labelSelector.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.labelSelector.matchLabels","title":".status.permissionClaims[*].selector.labelSelector.matchLabels","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.namedResource","title":".status.permissionClaims[*].selector.namedResource","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.namedResource[*]","title":".status.permissionClaims[*].selector.namedResource[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.namedResource[*].name","title":".status.permissionClaims[*].selector.namedResource[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.permissionClaims[*].selector.namedResource[*].namespace","title":".status.permissionClaims[*].selector.namedResource[*].namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.providerPrettyName","title":".status.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/","title":"APIServiceExportRequest","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#apiserviceexportrequest-crd-schema-reference-group-kube-bindio","title":"APIServiceExportRequest CRD schema reference (group kube-bind.io)","text":"APIServiceExportRequest is represents a request session of kubectl-bind-apiservice.  The service provider can prune these objects after some time.  Full name: apiserviceexportrequests.kube-bind.io Group: kube-bind.io Singular name: apiserviceexportrequest Plural name: apiserviceexportrequests Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object <p>parameters holds service provider specific parameters for this binding request.</p> array Required <p>resources is a list of resources that should be exported.</p> object string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>versions is a list of versions that should be exported. If this is empty a sensible default is chosen by the service provider.</p> string object <p>status contains reconciliation information for a service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>phase is the current phase of the binding request. It starts in Pending and transitions to Succeeded or Failed. See the condition for detailed information.</p> string <p>terminalMessage is a human readable message that describes the reason for the current phase.</p>"},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.parameters","title":".spec.parameters","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources","title":".spec.resources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*]","title":".spec.resources[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].group","title":".spec.resources[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].resource","title":".spec.resources[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].versions","title":".spec.resources[*].versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].versions[*]","title":".spec.resources[*].versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.phase","title":".status.phase","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.terminalMessage","title":".status.terminalMessage","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object <p>parameters holds service provider specific parameters for this binding request.</p> array <p>PermissionClaims records decisions about permission claims requested by the service provider. Access is granted per GroupResource.</p> object <p>PermissionClaim selects objects of a GVR that a service provider may request and that a consumer may accept and allow the service provider access to.</p> string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> object Required <p>Selector is a resource selector that selects objects of a GVR.</p> object <p>LabelSelector is a label selector that selects objects of a GVR.</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> array <p>NamedResource is a shorthand for selecting a single resource by name and namespace.</p> object <p>NamedResource selects a specific resource by name and namespace.</p> string Required <p>Name is the name of the resource. Name matches the metadata.name field of the underlying object.</p> string <p>Namespace represents namespace where an object of the given group/resource may be managed. Namespaces matches against the metadata.namespace field. If not provided, the object is assumed to be cluster-scoped. Namespaces field is ignored for namespaced isolation mode.</p> array Required <p>resources is a list of resources that should be exported.</p> object string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>versions is a list of versions that should be exported. If this is empty a sensible default is chosen by the service provider.</p> string object <p>status contains reconciliation information for a service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>phase is the current phase of the binding request. It starts in Pending and transitions to Succeeded or Failed. See the condition for detailed information.</p> string <p>terminalMessage is a human readable message that describes the reason for the current phase.</p>"},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.parameters","title":".spec.parameters","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims","title":".spec.permissionClaims","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*]","title":".spec.permissionClaims[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].group","title":".spec.permissionClaims[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].resource","title":".spec.permissionClaims[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector","title":".spec.permissionClaims[*].selector","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector","title":".spec.permissionClaims[*].selector.labelSelector","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*]","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].key","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].key","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].operator","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].operator","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values[*]","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchLabels","title":".spec.permissionClaims[*].selector.labelSelector.matchLabels","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.namedResource","title":".spec.permissionClaims[*].selector.namedResource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.namedResource[*]","title":".spec.permissionClaims[*].selector.namedResource[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.namedResource[*].name","title":".spec.permissionClaims[*].selector.namedResource[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.permissionClaims[*].selector.namedResource[*].namespace","title":".spec.permissionClaims[*].selector.namedResource[*].namespace","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources","title":".spec.resources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*]","title":".spec.resources[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].group","title":".spec.resources[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].resource","title":".spec.resources[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].versions","title":".spec.resources[*].versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].versions[*]","title":".spec.resources[*].versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.phase","title":".status.phase","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.terminalMessage","title":".status.terminalMessage","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/","title":"APIServiceExport","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#apiserviceexport-crd-schema-reference-group-kube-bindio","title":"APIServiceExport CRD schema reference (group kube-bind.io)","text":"APIServiceExport specifies the resource to be exported. It is mostly a CRD: - the spec is a CRD spec, but without webhooks - the status reflects that on the consumer cluster  Full name: apiserviceexports.kube-bind.io Group: kube-bind.io Singular name: apiserviceexport Plural name: apiserviceexports Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies the resource.</p> string <p>ClusterScopedIsolation specifies how cluster scoped service objects are isolated between multiple consumers on the provider side. It can be \u201cPrefixed\u201d, \u201cNamespaced\u201d, or \u201cNone\u201d.</p> string Required <p>group is the API group of the defined custom resource. Empty string means the core API group.     The resources are served under <code>/apis/&lt;group&gt;/...</code> or <code>/api</code> for the core group.</p> string Required <p>informerScope is the scope of the APIServiceExport. It can be either Cluster or Namespace.</p> <p>Cluster:    The konnector has permission to watch all namespaces at once and cluster-scoped resources.             This is more efficient than watching each namespace individually. Namespaced: The konnector has permission to watch only single namespaces.             This is more resource intensive. And it means cluster-scoped resources cannot be exported.</p> object Required <p>names specify the resource and kind names for the custom resource.</p> array <p>categories is a list of grouped resources this custom resource belongs to (e.g. \u2018all\u2019). This is published in API discovery documents, and used by clients to support invocations like <code>kubectl get all</code>.</p> string string Required <p>kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the <code>kind</code> attribute in API calls.</p> string <p>listKind is the serialized kind of the list for this resource. Defaults to \u201c<code>kind</code>List\u201d.</p> string Required <p>plural is the plural name of the resource to serve. The custom resources are served under <code>/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;</code>. Must match the name of the CustomResourceDefinition (in the form <code>&lt;names.plural&gt;.&lt;group&gt;</code>). Must be all lowercase.</p> array <p>shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like <code>kubectl get &lt;shortname&gt;</code>. It must be all lowercase.</p> string string <p>singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased <code>kind</code>.</p> string Required <p>scope indicates whether the defined custom resource is cluster- or namespace-scoped. Allowed values are <code>Cluster</code> and <code>Namespaced</code>.</p> array Required <p>versions is the API version of the defined custom resource.</p> <p>Note: the OpenAPI v3 schemas must be equal for all versions until CEL       version migration is supported.</p> object <p>APIServiceExportVersion describes one API version of a resource.</p> array <p>additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If no columns are specified, a single column displaying the age of the custom resource is used.</p> object <p>CustomResourceColumnDefinition specifies a column for server side printing.</p> string <p>description is a human readable description of this column.</p> string <p>format is an optional OpenAPI type definition for this column. The \u2018name\u2019 format is applied to the primary identifier column to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.</p> string Required <p>jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against each custom resource to produce the value for this column.</p> string Required <p>name is a human readable name for the column.</p> integer <p>priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a priority greater than 0.</p> string Required <p>type is an OpenAPI type definition for this column. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.</p> boolean <p>deprecated indicates this version of the custom resource API is deprecated. When set to true, API requests to this version receive a warning header in the server response. Defaults to false.</p> string <p>deprecationWarning overrides the default warning returned to API clients. May only be set when <code>deprecated</code> is true. The default warning indicates this version is deprecated and recommends use of the newest served version of equal or greater stability, if one exists.</p> string Required <p>name is the version name, e.g. \u201cv1\u201d, \u201cv2beta1\u201d, etc. The custom resources are served under this version at <code>/apis/&lt;group&gt;/&lt;version&gt;/...</code> if <code>served</code> is true.</p> object Required <p>schema describes the structural schema used for validation, pruning, and defaulting of this version of the custom resource.</p> object Required <p>openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.</p> boolean Required <p>served is a flag enabling/disabling this version from being served via REST APIs</p> boolean Required <p>storage indicates this version should be used when persisting custom resources to storage. There must be exactly one version with storage=true.</p> object <p>subresources specify what subresources this version of the defined custom resource have.</p> object <p>scale indicates the custom resource should serve a <code>/scale</code> subresource that returns an <code>autoscaling/v1</code> Scale object.</p> string <p>labelSelectorPath defines the JSON path inside of a custom resource that corresponds to Scale <code>status.selector</code>. Only JSON paths without the array notation are allowed. Must be a JSON Path under <code>.status</code> or <code>.spec</code>. Must be set to work with HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not a complex selector struct) which contains a serialized label selector in string form. More info: https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource If there is no value under the given path in the custom resource, the <code>status.selector</code> value in the <code>/scale</code> subresource will default to the empty string.</p> string Required <p>specReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale <code>spec.replicas</code>. Only JSON paths without the array notation are allowed. Must be a JSON Path under <code>.spec</code>. If there is no value under the given path in the custom resource, the <code>/scale</code> subresource will return an error on GET.</p> string Required <p>statusReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale <code>status.replicas</code>. Only JSON paths without the array notation are allowed. Must be a JSON Path under <code>.status</code>. If there is no value under the given path in the custom resource, the <code>status.replicas</code> value in the <code>/scale</code> subresource will default to 0.</p> object <p>status indicates the custom resource should serve a <code>/status</code> subresource. When enabled: 1. requests to the custom resource primary endpoint ignore changes to the <code>status</code> stanza of the object. 2. requests to the custom resource <code>/status</code> subresource ignore changes to anything other than the <code>status</code> stanza of the object.</p> object <p>status contains reconciliation information for the resource.</p> object <p>acceptedNames are the names that are actually being used to serve discovery. They may be different than the names in spec.</p> array <p>categories is a list of grouped resources this custom resource belongs to (e.g. \u2018all\u2019). This is published in API discovery documents, and used by clients to support invocations like <code>kubectl get all</code>.</p> string string Required <p>kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the <code>kind</code> attribute in API calls.</p> string <p>listKind is the serialized kind of the list for this resource. Defaults to \u201c<code>kind</code>List\u201d.</p> string Required <p>plural is the plural name of the resource to serve. The custom resources are served under <code>/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;</code>. Must match the name of the CustomResourceDefinition (in the form <code>&lt;names.plural&gt;.&lt;group&gt;</code>). Must be all lowercase.</p> array <p>shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like <code>kubectl get &lt;shortname&gt;</code>. It must be all lowercase.</p> string string <p>singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased <code>kind</code>.</p> array <p>conditions is a list of conditions that apply to the APIServiceExport. It is updated by the konnector on the consumer cluster.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> array <p>storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from <code>spec.versions</code> while they exist in this list.</p> string"},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.clusterScopedIsolation","title":".spec.clusterScopedIsolation","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.group","title":".spec.group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.informerScope","title":".spec.informerScope","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names","title":".spec.names","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.categories","title":".spec.names.categories","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.categories[*]","title":".spec.names.categories[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.kind","title":".spec.names.kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.listKind","title":".spec.names.listKind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.plural","title":".spec.names.plural","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.shortNames","title":".spec.names.shortNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.shortNames[*]","title":".spec.names.shortNames[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.singular","title":".spec.names.singular","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.scope","title":".spec.scope","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions","title":".spec.versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*]","title":".spec.versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns","title":".spec.versions[*].additionalPrinterColumns","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*]","title":".spec.versions[*].additionalPrinterColumns[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].description","title":".spec.versions[*].additionalPrinterColumns[*].description","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].format","title":".spec.versions[*].additionalPrinterColumns[*].format","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].jsonPath","title":".spec.versions[*].additionalPrinterColumns[*].jsonPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].name","title":".spec.versions[*].additionalPrinterColumns[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].priority","title":".spec.versions[*].additionalPrinterColumns[*].priority","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].type","title":".spec.versions[*].additionalPrinterColumns[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].deprecated","title":".spec.versions[*].deprecated","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].deprecationWarning","title":".spec.versions[*].deprecationWarning","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].name","title":".spec.versions[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].schema","title":".spec.versions[*].schema","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].schema.openAPIV3Schema","title":".spec.versions[*].schema.openAPIV3Schema","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].served","title":".spec.versions[*].served","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].storage","title":".spec.versions[*].storage","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources","title":".spec.versions[*].subresources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale","title":".spec.versions[*].subresources.scale","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale.labelSelectorPath","title":".spec.versions[*].subresources.scale.labelSelectorPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale.specReplicasPath","title":".spec.versions[*].subresources.scale.specReplicasPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale.statusReplicasPath","title":".spec.versions[*].subresources.scale.statusReplicasPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.status","title":".spec.versions[*].subresources.status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames","title":".status.acceptedNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.categories","title":".status.acceptedNames.categories","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.categories[*]","title":".status.acceptedNames.categories[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.kind","title":".status.acceptedNames.kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.listKind","title":".status.acceptedNames.listKind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.plural","title":".status.acceptedNames.plural","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.shortNames","title":".status.acceptedNames.shortNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.shortNames[*]","title":".status.acceptedNames.shortNames[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.singular","title":".status.acceptedNames.singular","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.storedVersions","title":".status.storedVersions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.storedVersions[*]","title":".status.storedVersions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies the resource.</p> string <p>ClusterScopedIsolation specifies how cluster scoped service objects are isolated between multiple consumers on the provider side. It can be \u201cPrefixed\u201d, \u201cNamespaced\u201d, or \u201cNone\u201d.</p> string Required <p>informerScope is the scope of the APIServiceExport. It can be either Cluster or Namespace.</p> <p>Cluster:    The konnector has permission to watch all namespaces at once and cluster-scoped resources.             This is more efficient than watching each namespace individually. Namespaced: The konnector has permission to watch only single namespaces.             This is more resource intensive. And it means cluster-scoped resources cannot be exported.</p> array <p>PermissionClaims records decisions about permission claims requested by the service provider. Access is granted per GroupResource.</p> object <p>PermissionClaim selects objects of a GVR that a service provider may request and that a consumer may accept and allow the service provider access to.</p> string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> object Required <p>Selector is a resource selector that selects objects of a GVR.</p> object <p>LabelSelector is a label selector that selects objects of a GVR.</p> array <p>matchExpressions is a list of label selector requirements. The requirements are ANDed.</p> object <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> string Required <p>key is the label key that the selector applies to.</p> string Required <p>operator represents a key\u2019s relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.</p> array <p>values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.</p> string object <p>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \u201ckey\u201d, the operator is \u201cIn\u201d, and the values array contains only \u201cvalue\u201d. The requirements are ANDed.</p> array <p>NamedResource is a shorthand for selecting a single resource by name and namespace.</p> object <p>NamedResource selects a specific resource by name and namespace.</p> string Required <p>Name is the name of the resource. Name matches the metadata.name field of the underlying object.</p> string <p>Namespace represents namespace where an object of the given group/resource may be managed. Namespaces matches against the metadata.namespace field. If not provided, the object is assumed to be cluster-scoped. Namespaces field is ignored for namespaced isolation mode.</p> array Required <p>resources is a list of resources that should be exported.</p> object string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>versions is a list of versions that should be exported. If this is empty a sensible default is chosen by the service provider.</p> string object <p>status contains reconciliation information for the resource.</p> array <p>conditions is a list of conditions that apply to the APIServiceExport. It is updated by the konnector on the consumer cluster.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p>"},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.clusterScopedIsolation","title":".spec.clusterScopedIsolation","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.informerScope","title":".spec.informerScope","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims","title":".spec.permissionClaims","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*]","title":".spec.permissionClaims[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].group","title":".spec.permissionClaims[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].resource","title":".spec.permissionClaims[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector","title":".spec.permissionClaims[*].selector","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector","title":".spec.permissionClaims[*].selector.labelSelector","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*]","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].key","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].key","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].operator","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].operator","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values[*]","title":".spec.permissionClaims[*].selector.labelSelector.matchExpressions[*].values[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.labelSelector.matchLabels","title":".spec.permissionClaims[*].selector.labelSelector.matchLabels","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.namedResource","title":".spec.permissionClaims[*].selector.namedResource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.namedResource[*]","title":".spec.permissionClaims[*].selector.namedResource[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.namedResource[*].name","title":".spec.permissionClaims[*].selector.namedResource[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.permissionClaims[*].selector.namedResource[*].namespace","title":".spec.permissionClaims[*].selector.namedResource[*].namespace","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources","title":".spec.resources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*]","title":".spec.resources[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*].group","title":".spec.resources[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*].resource","title":".spec.resources[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*].versions","title":".spec.resources[*].versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*].versions[*]","title":".spec.resources[*].versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/","title":"APIServiceNamespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#apiservicenamespace-crd-schema-reference-group-kube-bindio","title":"APIServiceNamespace CRD schema reference (group kube-bind.io)","text":"APIServiceNamespace defines how consumer namespaces map to service namespaces. These objects are created by the konnector, and a service namespace is then created by the service provider.  The name of the APIServiceNamespace equals the namespace name in the consumer cluster.  Full name: apiservicenamespaces.kube-bind.io Group: kube-bind.io Singular name: apiservicenamespace Plural name: apiservicenamespaces Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies a service namespace.</p> object <p>status contains reconciliation information for a service namespace</p> string <p>namespace is the service provider namespace name that will be bound to the consumer namespace named like this object.</p>"},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.status.namespace","title":".status.namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies a service namespace.</p> object <p>status contains reconciliation information for a service namespace</p> string <p>namespace is the service provider namespace name that will be bound to the consumer namespace named like this object.</p>"},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.status.namespace","title":".status.namespace","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/","title":"ClusterBinding","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#clusterbinding-crd-schema-reference-group-kube-bindio","title":"ClusterBinding CRD schema reference (group kube-bind.io)","text":"ClusterBinding represents a bound consumer cluster. It lives in a service provider cluster and is a singleton named \"cluster\".  Full name: clusterbindings.kube-bind.io Group: kube-bind.io Singular name: clusterbinding Plural name: clusterbindings Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec represents the data in the newly created ClusterBinding.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different ServiceBindings.</p> object <p>serviceProviderSpec contains all the data and information about the service which has been bound to the service binding request. The service providers decide what they need and what to configure based on what then include in this field, such as service region, type, tiers, etc\u2026</p> object <p>status contains reconciliation information for the service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>heartbeatInterval is the maximal interval between heartbeats that the konnector promises to send. The service provider can assume that the konnector is not unhealthy if it does not receive a heartbeat within this time.</p> string <p>konnectorVersion is the version of the konnector that is running on the consumer cluster.</p> string <p>lastHeartbeatTime is the last time the konnector updated the status.</p>"},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.providerPrettyName","title":".spec.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.serviceProviderSpec","title":".spec.serviceProviderSpec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.heartbeatInterval","title":".status.heartbeatInterval","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.konnectorVersion","title":".status.konnectorVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.lastHeartbeatTime","title":".status.lastHeartbeatTime","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec represents the data in the newly created ClusterBinding.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different ServiceBindings.</p> object <p>serviceProviderSpec contains all the data and information about the service which has been bound to the service binding request. The service providers decide what they need and what to configure based on what then include in this field, such as service region, type, tiers, etc\u2026</p> object <p>status contains reconciliation information for the service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>heartbeatInterval is the maximal interval between heartbeats that the konnector promises to send. The service provider can assume that the konnector is not unhealthy if it does not receive a heartbeat within this time.</p> string <p>konnectorVersion is the version of the konnector that is running on the consumer cluster.</p> string <p>lastHeartbeatTime is the last time the konnector updated the status.</p>"},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.providerPrettyName","title":".spec.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.serviceProviderSpec","title":".spec.serviceProviderSpec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.heartbeatInterval","title":".status.heartbeatInterval","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.konnectorVersion","title":".status.konnectorVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.lastHeartbeatTime","title":".status.lastHeartbeatTime","text":""},{"location":"setup/","title":"Setting Up kube-bind","text":"<p>kube-bind supports multiple deployment scenarios and backend providers to meet different requirements.</p>"},{"location":"setup/#setup-options","title":"Setup Options","text":""},{"location":"setup/#standard-kubernetes-setup","title":"Standard Kubernetes Setup","text":"<ul> <li>Quickstart: Get started quickly with the default provider</li> <li>Helm Deployment: Production deployment using Helm charts</li> <li>Local Setup with Kind: Local development environment</li> <li>kubectl Plugin: Install and use the kubectl-bind plugin</li> </ul>"},{"location":"setup/#advanced-multi-cluster-setup","title":"Advanced Multi-Cluster Setup","text":"<ul> <li>KCP Integration: Advanced multi-tenant setup with kcp workspaces and APIExports</li> </ul>"},{"location":"setup/#architecture-overview","title":"Architecture Overview","text":"<p>Starting with v0.5.0, kube-bind uses a multicluster-runtime architecture that supports:</p> <ul> <li>Multiple Providers: Choose between standard Kubernetes or KCP backends</li> <li>Enhanced API: v1alpha2 API with resource-based exports and BoundSchema support</li> <li>Flexible Deployment: Support for various cluster topologies and requirements</li> </ul> <p>Choose the setup that best fits your use case:</p> <ul> <li>Use Quickstart or Local Setup with Kind for development and testing</li> <li>Use Helm Deployment for production environments with standard Kubernetes</li> <li>Use KCP Integration for advanced multi-tenant scenarios with workspace isolation</li> </ul>"},{"location":"setup/#quickstart","title":"Quickstart","text":"<p>Get started with kube bind.</p>"},{"location":"setup/#local-kube-bind-with-kind","title":"Local kube-bind with kind","text":""},{"location":"setup/#installation-with-helm","title":"Installation with Helm","text":"<p>Install kube-bind on an existing Kubernetes cluster via the official Helm chart.</p>"},{"location":"setup/#kubectl-plugins","title":"kubectl Plugins","text":"<p>How to install and use the kubectl bind plugin.</p>"},{"location":"setup/helm/","title":"Installation with Helm","text":"<p>If you reading this, we need help populating this page :)</p>"},{"location":"setup/kcp-setup/","title":"kcp Setup","text":"<p>This guide shows how to set up kube-bind with the kcp provider, which enables advanced multi-cluster and multi-tenant scenarios through kcp workspaces.</p>"},{"location":"setup/kcp-setup/#overview","title":"Overview","text":"<p>The kcp provider integrates kube-bind with kcp, enabling:</p> <ul> <li>Workspace-based isolation: Each binding can operate in isolated kcp workspaces</li> <li>Advanced multi-tenancy: Provider and consumer separation through logical clusters where backend can be in single workspace or multiple workspaces</li> <li>APIExport integration: Leverages kcp's APIExport mechanism for service exposure</li> <li>Scalable architecture: Supports large-scale multi-cluster deployments</li> </ul>"},{"location":"setup/kcp-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>kcp instance running and accessible</li> <li>dex for OIDC authentication</li> <li>kube-bind binaries built (<code>make build</code>)</li> </ul>"},{"location":"setup/kcp-setup/#setup-steps","title":"Setup Steps","text":""},{"location":"setup/kcp-setup/#1-start-kcp","title":"1. Start KCP","text":"<pre><code>make run-kcp\n</code></pre>"},{"location":"setup/kcp-setup/#2-start-dex-oidc-provider","title":"2. Start Dex OIDC Provider","text":"<p>Clone and configure dex:</p> <pre><code>git clone https://github.com/dexidp/dex.git\ncd dex &amp;&amp; make build\n</code></pre> <p>Configure dex (<code>examples/config-dev.yaml</code>):</p> <pre><code>staticClients:\n- id: kube-bind\n  redirectURIs:\n  - 'http://127.0.0.1:8080/callback'\n  name: 'Kube Bind'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n</code></pre> <p>Start dex:</p> <pre><code>./bin/dex serve examples/config-dev.yaml\n</code></pre>"},{"location":"setup/kcp-setup/#3-bootstrap-kcp","title":"3. Bootstrap KCP","text":"<p>Create the kube-bind provider workspace and APIExport:</p> <pre><code>cp .kcp/admin.kubeconfig .kcp/backend.kubeconfig\nexport KUBECONFIG=.kcp/backend.kubeconfig\n./bin/kcp-init --kcp-kubeconfig $KUBECONFIG\n</code></pre>"},{"location":"setup/kcp-setup/#4-start-backend-with-kcp-provider","title":"4. Start Backend with KCP Provider","text":"<p>Switch to the kube-bind workspace:</p> <pre><code>kubectl ws use :root:kube-bind\n</code></pre> <p>Start the backend with KCP provider:</p> <pre><code>./bin/backend \\\n  --multicluster-runtime-provider kcp \\\n  --server-url=$(kubectl get apiexportendpointslice kube-bind.io -o jsonpath=\"{.status.endpoints[0].url}\") \\\n  --oidc-issuer-client-secret=ZXhhbXBsZS1hcHAtc2VjcmV0 \\\n  --oidc-issuer-client-id=kube-bind \\\n  --oidc-issuer-url=http://127.0.0.1:5556/dex \\\n  --oidc-callback-url=http://127.0.0.1:8080/callback \\\n  --pretty-name=\"BigCorp.com\" \\\n  --namespace-prefix=\"kube-bind-\" \\\n  --cookie-signing-key=bGMHz7SR9XcI9JdDB68VmjQErrjbrAR9JdVqjAOKHzE= \\\n  --cookie-encryption-key=wadqi4u+w0bqnSrVFtM38Pz2ykYVIeeadhzT34XlC1Y= \\\n  --schema-source apiresourceschemas\n</code></pre>"},{"location":"setup/kcp-setup/#5-create-provider-workspace","title":"5. Create Provider Workspace","text":"<p>Create a provider workspace for hosting services:</p> <pre><code>cp .kcp/admin.kubeconfig .kcp/provider.kubeconfig\nexport KUBECONFIG=.kcp/provider.kubeconfig\nkubectl ws use :root\nkubectl ws create provider --enter\n</code></pre>"},{"location":"setup/kcp-setup/#6-bind-apiexport-to-provider","title":"6. Bind APIExport to Provider","text":"<p>Bind the kube-bind APIExport to the provider workspace:</p> <pre><code>kubectl kcp bind apiexport root:kube-bind:kube-bind.io \\\n  --accept-permission-claim clusterrolebindings.rbac.authorization.k8s.io \\\n  --accept-permission-claim clusterroles.rbac.authorization.k8s.io \\\n  --accept-permission-claim customresourcedefinitions.apiextensions.k8s.io \\\n  --accept-permission-claim serviceaccounts.core \\\n  --accept-permission-claim configmaps.core \\\n  --accept-permission-claim secrets.core \\\n  --accept-permission-claim namespaces.core \\\n  --accept-permission-claim roles.rbac.authorization.k8s.io \\\n  --accept-permission-claim rolebindings.rbac.authorization.k8s.io \\\n  --accept-permission-claim apiresourceschemas.apis.kcp.io\n</code></pre>"},{"location":"setup/kcp-setup/#7-create-example-resources","title":"7. Create Example Resources","text":"<p>Deploy example APIExport and APIResourceSchemas:</p> <pre><code>kubectl create -f contrib/kcp/deploy/examples/apiexport.yaml\nkubectl create -f contrib/kcp/deploy/examples/apiresourceschema-cowboys.yaml\nkubectl create -f contrib/kcp/deploy/examples/apiresourceschema-sheriffs.yaml\n\n# Enable recursive binding\nkubectl kcp bind apiexport root:provider:cowboys-stable\n</code></pre>"},{"location":"setup/kcp-setup/#8-get-logical-cluster-information","title":"8. Get Logical Cluster Information","text":"<p>Retrieve the logical cluster URL for consumer setup:</p> <pre><code>kubectl get logicalcluster\n# NAME      PHASE   URL                                                    AGE\n# cluster   Ready   https://192.168.2.166:6443/clusters/2xh2v3gzjhn4tmve\n</code></pre>"},{"location":"setup/kcp-setup/#consumer-setup","title":"Consumer Setup","text":""},{"location":"setup/kcp-setup/#1-create-consumer-workspace","title":"1. Create Consumer Workspace","text":"<pre><code>cp .kcp/admin.kubeconfig .kcp/consumer.kubeconfig\nexport KUBECONFIG=.kcp/consumer.kubeconfig\nkubectl ws use :root\nkubectl ws create consumer --enter\n</code></pre>"},{"location":"setup/kcp-setup/#2-perform-binding","title":"2. Perform Binding","text":"<p>Generate the APIServiceExport YAML:</p> <pre><code>./bin/kubectl-bind http://127.0.0.1:8080/clusters/&lt;logical-cluster-id&gt;/exports --dry-run -o yaml &gt; apiserviceexport.yaml\n</code></pre> <p>Extract the kubeconfig for binding:</p> <pre><code>kubectl get secret &lt;secret-name&gt; -n kube-bind -o jsonpath='{.data.kubeconfig}' | base64 -d &gt; remote.kubeconfig\n</code></pre> <p>Perform the binding:</p> <pre><code>./bin/kubectl-bind apiservice \\\n  --remote-kubeconfig remote.kubeconfig \\\n  -f apiserviceexport.yaml \\\n  --skip-konnector \\\n  --remote-namespace kube-bind-&lt;random-suffix&gt;\n</code></pre>"},{"location":"setup/kcp-setup/#3-start-konnector","title":"3. Start Konnector","text":"<pre><code>export KUBECONFIG=.kcp/consumer.kubeconfig\ngo run ./cmd/konnector/ --lease-namespace default\n</code></pre>"},{"location":"setup/kcp-setup/#4-test-the-setup","title":"4. Test the Setup","text":"<p>Create example resources:</p> <pre><code>kubectl apply -f contrib/kcp/deploy/examples/cowboy.yaml\n</code></pre>"},{"location":"setup/kcp-setup/#advanced-features","title":"Advanced Features","text":""},{"location":"setup/kcp-setup/#multiple-consumers","title":"Multiple Consumers","text":"<p>You can create multiple consumer workspaces to test multi-tenant scenarios:</p> <pre><code># Create second consumer\ncp .kcp/admin.kubeconfig .kcp/consumer2.kubeconfig\nexport KUBECONFIG=.kcp/consumer2.kubeconfig\nkubectl ws use :root\nkubectl ws create consumer2 --enter\n\n# Repeat binding process with different namespace\n# Start konnector on different port\ngo run ./cmd/konnector/ --lease-namespace default --server-address :8091\n</code></pre>"},{"location":"setup/kcp-setup/#debugging","title":"Debugging","text":"<p>To debug the setup, use the following commands:</p> <pre><code># Switch to debug workspace\ncp .kcp/admin.kubeconfig .kcp/debug.kubeconfig\nexport KUBECONFIG=.kcp/debug.kubeconfig\nkubectl ws use :root:kube-bind\n\n# Check available resources\nkubectl-s \"$(kubectl get apiexportendpointslice kube-bind.io -o jsonpath=\"{.status.endpoints[0].url}\")/clusters/*\" api-resources\n\n# List CRDs\nkubectl-s \"$(kubectl get apiexportendpointslice kube-bind.io -o jsonpath=\"{.status.endpoints[0].url}\")/clusters/*\" get crd\n</code></pre>"},{"location":"setup/kcp-setup/#key-differences-from-standard-setup","title":"Key Differences from Standard Setup","text":"<ul> <li>Provider Selection: Uses <code>--multicluster-runtime-provider kcp</code> flag</li> <li>Workspace Management: Requires kcp workspace creation and management</li> <li>APIExport Integration: Leverages kcp's APIExport mechanism to enable shared backed service.</li> <li>URL Structure: Uses kcp-specific URLs with cluster identifiers. In production, this should be abstracted by a service wrapper.</li> <li>Advanced Isolation: Provides workspace-level isolation beyond namespaces</li> </ul>"},{"location":"setup/kubectl-plugin/","title":"kubectl Plugins","text":"<p>kube-bind provides kubectl plugins to interact with kube-bind protocol.</p> <p>or use krew:</p> <pre><code>$ kubectl krew index add bind https://github.com/kube-bind/krew-index.git\n$ kubectl krew install bind/bind\n</code></pre>"},{"location":"setup/local-setup-with-kind/","title":"Local kube-bind with kind","text":"<p>This guide will walk you through setting up kube-bind between two Kubernetes clusters, where</p> <ul> <li>Backend cluster:</li> <li>Deploys dex, cert-manager and kube-bind/backend</li> <li>Provides kube-bind compatible backend for MangoDB resources</li> <li>App cluster:</li> <li>Provides an application consuming MangoDBs</li> </ul>"},{"location":"setup/local-setup-with-kind/#pre-requisites","title":"Pre-requisites","text":"<p>To start, you'll need following tools available in your system or a VM:</p> <ul> <li><code>kind</code></li> <li><code>kubectl</code></li> <li><code>kubectl-bind</code> (a kubectl plugin)</li> <li><code>helm</code></li> <li><code>jq</code></li> </ul> <p>To install <code>kubectl-bind</code> plugin, please download the archive for your platform from the link above, extract it, and place the <code>kubectl-bind</code> executable in your system's <code>$PATH</code>.</p> <p>Tip: In case of encountering <code>Too many open files</code> error when deploying the Kind clusters, run following commands:</p> <pre><code>sudo sysctl fs.inotify.max_user_watches=524288\nsudo sysctl fs.inotify.max_user_instances=512\n</code></pre> <p>See the kind documentation for more details.</p>"},{"location":"setup/local-setup-with-kind/#provider-cluster","title":"Provider cluster","text":"<p>The provider cluster we'll prepare in this section will provide a kube-bind compatible backend that will provide a controller for a demo resource \"MangoDB\" we'll consume in another cluster later.</p> <p>What is MangoDB? It is just an example CRD to demonstrate kube-bind's capabilities and testing, without any workloads. See its definition in /test/e2e/bind/fixtures/provider/crd-mangodb.yaml.</p>"},{"location":"setup/local-setup-with-kind/#step-one-create-the-backend-cluster","title":"Step one: create the Backend cluster","text":"<p>First, stash the host's external IP in a variable as we're going to use it often:</p> <pre><code>export BACKEND_HOST_IP=\"$(hostname -i | cut -d' ' -f1)\"\n</code></pre> <p>Create a Kind cluster named \"backend\":</p> <pre><code>cat &lt;&lt; EOF_BackendClusterDefinition | kind create cluster --config=-\napiVersion: kind.x-k8s.io/v1alpha4\nkind: Cluster\nname: backend\nnetworking:\n  apiServerAddress: ${BACKEND_HOST_IP}\nnodes:\n- role: control-plane\n  extraPortMappings:\n  # MangoDB export endpoint\n  - containerPort: 30080\n    hostPort: 8080\n    protocol: TCP\n  # dex endpoint\n  - containerPort: 30556\n    hostPort: 5556\n    protocol: TCP\nEOF_BackendClusterDefinition\n</code></pre> <p>Note: the port mappings will become clear later on, but in general this setup is solely specific to how Kind exposes ports of its nodes on the host. Specifically, we're exposing ports from containers through NodePort services on Kind's nodes, and to make these ports available on the host we need to map them to host's ports through <code>extraPortMappings</code>.</p>"},{"location":"setup/local-setup-with-kind/#step-two-deploy-an-identity-provider","title":"Step two: deploy an identity provider","text":"<p>kube-bind relies on OAuth2 for securely authenticating consumer and producer clusters. There are many ways to handle that in Kubernetes, for example with dex IDP. It depends on cert-manager, which we'll deploy first:</p> <pre><code>helm repo add jetstack https://charts.jetstack.io\nhelm install \\\n    --create-namespace \\\n    --namespace pki \\\n    --version v1.16.2 \\\n    --set crds.enabled=true \\\n    cert-manager jetstack/cert-manager\n</code></pre> <p>And now let's deploy dex:</p> <pre><code>helm repo add dex https://charts.dexidp.io\ncat &lt;&lt; EOF_DEXDeploymentConfig |\nconfig:\n    staticClients:\n      - id: kube-bind\n        redirectURIs:\n          - 'http://${BACKEND_HOST_IP}:8080/callback'\n        name: 'Kube Bind'\n        secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\n    issuer: http://${BACKEND_HOST_IP}:5556/dex\n\n    storage:\n      type: kubernetes\n      config:\n        inCluster: true\n\n    web:\n      http: 127.0.0.1:5556\n\n    telemetry:\n      http: 127.0.0.1:5558\n\n    grpc:\n      addr: 127.0.0.1:5557\n\n    connectors:\n      - type: mockCallback\n        id: mock\n        name: Example\n\n    enablePasswordDB: true\n    staticPasswords:\n      - email: \"admin@example.com\"\n        hash: \"\\$2a\\$10\\$2b2cU8CPhOTaGrs1HRQuAueS7JTT5ZHsHSzYiFPm1leZck7Mc8T4W\"\n        username: \"admin\"\n        userID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\nEOF_DEXDeploymentConfig\nhelm install \\\n    --create-namespace \\\n    --namespace idp \\\n    --set service.type=NodePort \\\n    --set service.ports.http.nodePort=30556 \\\n    dex dex/dex \\\n    -f -\n</code></pre>"},{"location":"setup/local-setup-with-kind/#step-three-deploy-the-mangodb-kube-bind-backend","title":"Step three: deploy the MangoDB kube-bind backend","text":"<p>Now we'll deploy a kube-bind--compatible backend for MangoDB. Let's start with kube-bind CRDs:</p> <pre><code>kubectl apply -f deploy/crd\n</code></pre> <p>And now CRDs for MangoDB:</p> <pre><code>kubectl apply -f test/e2e/bind/fixtures/provider/crd-mangodb.yaml\n</code></pre> <p>To set up the MangoDB backend we'll need: * ServiceAccount and ClusterRoleBinding for kube-bind's user, * Deployment that runs the MangoDB backend * Service that exposes the backend's address</p> <pre><code>kubectl create namespace backend\n# This is the address that will be used when generating kubeconfigs the App cluster,\n# and so we need to be able to reach it from outside.\nexport BACKEND_KUBE_API_EXTERNAL_ADDRESS=\"$(kubectl config view --minify -o json | jq '.clusters[0].cluster.server' -r)\"\n# For demo example let's just bind \"cluster-admin\" ClusterRole to backend's \"default\" ServiceAccount.\nkubectl create clusterrolebinding backend-admin --clusterrole cluster-admin --serviceaccount backend:default\n# Create a new Deployment for the MangoDB backend.\nkubectl --namespace backend \\\n    create deployment mangodb \\\n    --image ghcr.io/kube-bind/backend:v0.5.0 \\\n    --port 8080 \\\n    -- /ko-app/backend \\\n        --listen-address 0.0.0.0:8080 \\\n        --external-address \"${BACKEND_KUBE_API_EXTERNAL_ADDRESS}\" \\\n        --oidc-issuer-client-secret=ZXhhbXBsZS1hcHAtc2VjcmV0 \\\n        --oidc-issuer-client-id=kube-bind \\\n        --oidc-issuer-url=http://${BACKEND_HOST_IP}:5556/dex \\\n        --oidc-callback-url=http://${BACKEND_HOST_IP}:8080/callback \\\n        --pretty-name=\"BigCorp.com\" \\\n        --namespace-prefix=\"kube-bind-\" \\\n        --cookie-signing-key=bGMHz7SR9XcI9JdDB68VmjQErrjbrAR9JdVqjAOKHzE= \\\n        --cookie-encryption-key=wadqi4u+w0bqnSrVFtM38Pz2ykYVIeeadhzT34XlC1Y=\n# Expose mangodb's container port 8080 as a NodePort at 30080. We've already configured\n# Kind to expose 30800 at host's 8080.\nkubectl --namespace backend \\\n    create service nodeport mangodb \\\n    --tcp 8080 \\\n    --node-port 30080\n</code></pre> <p>And that's really all there's to it. After that, you should see a kubectl output similar to this:</p> <pre><code>$ kubectl --namespace backend get all\nNAME                          READY   STATUS    RESTARTS   AGE\npod/mangodb-6ff44cbbf-x7cjm   1/1     Running   0          100s\n\nNAME              TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE\nservice/mangodb   NodePort   10.96.10.212   &lt;none&gt;        8080:30080/TCP   100s\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/mangodb   1/1     1            1           100s\n\nNAME                                DESIRED   CURRENT   READY   AGE\nreplicaset.apps/mangodb-6ff44cbbf   1         1         1       100s\n</code></pre>"},{"location":"setup/local-setup-with-kind/#consumer-app-cluster","title":"Consumer App cluster","text":"<p>The App cluster will consume MangoDB CRs provided by the Backend.</p>"},{"location":"setup/local-setup-with-kind/#step-one-create-the-app-cluster","title":"Step one: create the App cluster","text":"<p>Again, let's start by stashing the host's external IP in a variable as we're going to use it often (possibly the same one as for the Backend cluster):</p> <pre><code>export APP_HOST_IP=\"$(hostname -i | cut -d' ' -f1)\"\n</code></pre> <p>Create a Kind cluster named \"app\":</p> <pre><code>cat &lt;&lt; EOF_AppClusterDefinition | kind create cluster --config=-\napiVersion: kind.x-k8s.io/v1alpha4\nkind: Cluster\nname: app\nnetworking:\n  apiServerAddress: ${APP_HOST_IP}\nEOF_AppClusterDefinition\n</code></pre>"},{"location":"setup/local-setup-with-kind/#binding-mangodb-backend","title":"Binding MangoDB backend","text":"<p>Now we'll bring in MangoDB CRDs from the Backend cluster (you can run <code>kubectl get crds</code> to see there are none yet):</p> <pre><code>$ kubectl bind http://${BACKEND_HOST_IP}:8080/export\nDISCLAIMER: This is a prototype. It will change in incompatible ways at any time.\n\n\ud83d\udce6 Created kube-bind namespace.\n\n\n\nTo authenticate, visit in your browser:\n\n    http://${BACKEND_HOST_IP}:8080/authorize?c=3QnoGw&amp;p=39595&amp;s=b2YLH6\n</code></pre> <p>The client is now waiting for you to visit the address similar to the one displayed in the output above. After completing the steps to create an OAuth2 token, it is then used by the kube-bind backend to pass the ServiceAccount's kubeconfig (in the Backend cluster) to the App cluster securely: 1. on the \"Log in to dex\" landing page, select \"Log in with Example\", 2. on the \"Grant Access\" page, click the \"Grant Access\" button, 3. lastly, click \"Bind\" when the page displays the mangodb resource.</p> <p>Go back to the terminal where <code>kubectl bind</code> command was run, and you should see the following output: <pre><code>\ud83d\udd11 Successfully authenticated to http://${BACKEND_HOST_IP}:8080/export\n\ud83d\udd12 Created secret kube-bind/kubeconfig-x9bd5 for host https://${BACKEND_HOST_IP}:34595, namespace kube-bind-gfsqn\n\ud83d\ude80 Executing: kubectl bind apiservice --remote-kubeconfig-namespace kube-bind --remote-kubeconfig-name kubeconfig-x9bd5 -f -\n\u2728 Use \"-o yaml\" and \"--dry-run\" to get the APIServiceExportRequest.\n   and pass it to \"kubectl bind apiservice\" directly. Great for automation.\n\ud83d\ude80 Deploying konnector v0.4.6 to namespace kube-bind.\n   Waiting for the konnector to be ready..............\n\u2705 Created APIServiceBinding mangodbs.mangodb.com\n\nNAME                                                  PROVIDER   READY   MESSAGE   AGE\napiservicebinding.kube-bind.io/mangodbs.mangodb.com              False   Pending   0s\n</code></pre></p>"},{"location":"setup/local-setup-with-kind/#step-two-demo-time","title":"Step two: demo time!","text":"<p>Let's see if we have CRDs for the MangoDB resource:</p> <pre><code>$ kubectl get crds\nNAME                              CREATED AT\napiservicebindings.kube-bind.io   2024-12-19T08:46:13Z\nmangodbs.mangodb.com              2024-12-19T08:46:17Z\n</code></pre> <p>We do! Now create a CR for it:</p> <pre><code>kubectl create -f - &lt;&lt; EOF_MangoDBDefinition\napiVersion: mangodb.com/v1alpha1\nkind: MangoDB\nmetadata:\n  name: my-db\nspec:\n  tokenSecret: my-secret\n  region: eu-west-1\n  tier: Shared\nEOF_MangoDBDefinition\nkubectl describe mangodb my-db\n</code></pre> <p>And finally, switch to the backend cluster and see that the CR is mirrored there: <pre><code>$ kubectl config use-context kind-backend\nSwitched to context \"kind-backend\".\n# Your \"kube-bind-&lt;Generated string&gt;-default\" will be different.\n$ kubectl -n kube-bind-rp2s9-default describe mangodb my-db\nName:         my-db\nNamespace:    kube-bind-rp2s9-default\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\nAPI Version:  mangodb.com/v1alpha1\nKind:         MangoDB\nMetadata:\n  Creation Timestamp:  2024-12-19T08:48:07Z\n  Generation:          1\n  Resource Version:    1564\n  UID:                 bed9f6d6-79d5-4535-8b20-690470b23378\nSpec:\n  Backup:        false\n  Region:        eu-west-1\n  Tier:          Shared\n  Token Secret:  my-secret\nEvents:          &lt;none&gt;\n</code></pre></p>"},{"location":"setup/local-setup-with-kind/#step-three-clean-up","title":"Step three: clean up","text":"<p>Once you're done, you may clean up the setup simply by deleting the two kind clusters:</p> <pre><code>kind delete cluster --name backend\nkind delete cluster --name app\n</code></pre>"},{"location":"setup/quickstart/","title":"Quickstart","text":""},{"location":"setup/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>kubectl</li> </ul>"},{"location":"setup/quickstart/#start-with-kube-bind","title":"Start with Kube-Bind","text":"<p>This section allows you to run local kube-bind backend and konnector with the standard Kubernetes provider.</p> <p>Starting with v0.5.0, kube-bind supports multiple backend providers through multicluster-runtime:</p> <ul> <li>Standard Provider (default): Works with regular Kubernetes clusters</li> <li>KCP Provider: Advanced multi-tenant setup with kcp workspaces (see KCP Setup Guide)</li> </ul> <p>This quickstart uses the default provider. For kcp integration, see the KCP Setup Guide.</p>"},{"location":"setup/quickstart/#using-kcp-for-local-development","title":"Using KCP for Local Development","text":"<p>For local development, we use kcp to create multiple logical clusters under a single kcp instance, making them available and accessible via the same URL.</p> <p>To run kcp, you need to have a kcp binary.</p> <pre><code>$ make run-kcp\n</code></pre> <p>To run the current backend, there must be an OIDC issuer installed in place to do the the oauth2 workflow.</p> <p>We use dex to manage OIDC, following the steps below you can run a local OIDC issuer using dex:</p> <ul> <li>First, clone the dex repo: <code>git clone https://github.com/dexidp/dex.git</code></li> <li><code>cd dex</code> and then build the dex binary <code>make build</code></li> <li>The binary will be created in <code>bin/dex</code></li> <li>Adjust the config file(<code>examples/config-dev.yaml</code>) for dex by specifying the server callback method:   <pre><code>staticClients:\n- id: kube-bind\n  redirectURIs:\n  - 'http://127.0.0.1:8080/callback'\n  name: 'Kube Bind'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n</code></pre></li> <li>Run dex: <code>./bin/dex serve examples/config-dev.yaml</code></li> </ul> <p>Next you should be able to run the backend. For it you need a kubernetes cluster (e.g. kind) accessible.</p> <p>Note: make sure before running the backend that you have the dex server up and running as mentioned above and that you have at least one k8s cluster. Take a look at the backend option in the cmd/main.go file</p> <p>Create copy of kcp kubeconfig and create provider cluster:</p> <pre><code>cp .kcp/admin.kubeconfig .kcp/provider.kubeconfig\nexport KUBECONFIG=.kcp/provider.kubeconfig\nkubectl ws create provider --enter\n</code></pre> <ul> <li>apply the CRDs:</li> </ul> <p><pre><code>kubectl apply -f deploy/crd\n</code></pre> * In order to populate binding list on website, we need a CRD with label <code>kube-bind.io/exported: true</code>. Apply example APIResourceSchema for the CRD: <code>kubectl apply -f deploy/examples/crd-mangodb.yaml</code></p> <pre><code>kubectl apply -f deploy/examples/crd-mangodb.yaml\nkubectl apply -f deploy/examples/crd-foo.yaml\n</code></pre> <ul> <li>start the backend binary with the right flags:    <pre><code>make build\n\nbin/backend \\\n  --oidc-issuer-client-secret=ZXhhbXBsZS1hcHAtc2VjcmV0 \\\n  --oidc-issuer-client-id=kube-bind \\\n  --oidc-issuer-url=http://127.0.0.1:5556/dex \\\n  --oidc-callback-url=http://127.0.0.1:8080/callback \\\n  --pretty-name=\"BigCorp.com\" \\\n  --namespace-prefix=\"kube-bind-\" \\\n  --cookie-signing-key=bGMHz7SR9XcI9JdDB68VmjQErrjbrAR9JdVqjAOKHzE= \\\n  --cookie-encryption-key=wadqi4u+w0bqnSrVFtM38Pz2ykYVIeeadhzT34XlC1Y= \\\n  --consumer-scope=cluster\n</code></pre></li> </ul> <p>where <code>ZXhhbXBsZS1hcHAtc2VjcmV0</code> matches the value of the dex config file.</p> <p>The <code>--cookie-signing-key</code> and <code>--cookie-encryption-key</code> settings can be generated using:</p> <pre><code>$ openssl rand -base64 32\nWQh88mNOY0Z3tLy1/WOud7qIEEBxz+POc4j8BsYenYo=\n</code></pre> <p>The <code>--cookie-signing-key</code> option is required and supports 32 and 64 byte lengths. The <code>--cookie-encryption-key</code> option is optional and supports byte lengths of 16, 24, 32 for AES-128, AES-192, or AES-256.</p>"},{"location":"setup/quickstart/#consumer","title":"Consumer","text":"<p>Now create consumer cluster:</p> <pre><code>export KUBECONFIG=.kcp/admin.kubeconfig\nkubectl ws create consumer --enter\n</code></pre> <p>Now create the APIServiceExportRequest:</p> <pre><code>./bin/kubectl-bind http://127.0.0.1:8080/exports --dry-run -o yaml &gt; apiserviceexport.yaml\n\n# This will wait for konnector to be ready. Once this gets running - start the konnector bellow\n# IMPORTANT: Check namespace to be used!\n./bin/kubectl-bind apiservice --remote-kubeconfig .kcp/provider.kubeconfig -f apiserviceexport.yaml  --skip-konnector --remote-namespace &lt;namespace&gt;\n\n# run konnector in different terminal\nexport KUBECONFIG=.kcp/admin.kubeconfig\ngo run ./cmd/konnector/ --lease-namespace default\n</code></pre> <p>Create mangoDB object:</p> <pre><code>kubectl create -f deploy/examples/mangodb.yaml\n</code></pre>"}]}