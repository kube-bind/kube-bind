{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kube-bind Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>kube-bind is a prototype project that aims to provide better support for service providers and consumers that reside in distinct Kubernetes clusters.</p> <ul> <li>A service provider defines its API in terms of CRDs and associated permission claims/limitations, and exports it for use from other clusters.</li> <li>Service consumers identify the services they want to consume.</li> <li>The service CRDs get installed in the service consumer clusters, with objects of the defined kinds written and read by the service consumers.</li> <li>The service provider indirectly reads and writes those objects as the interface to the service that it provides.</li> <li>The service provider does not inject controllers/operators into the service consumer's cluster.</li> <li>A single vendor-neutral, OpenSource agent per consumer cluster connects it with the requested services.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To get started with trying out kube-bind on your local system, check out our Quickstart instructions.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We \u2764\ufe0f our contributors! If you're interested in helping us out, please head over to our Contributing guide.</p>"},{"location":"#getting-in-touch","title":"Getting in touch","text":"<p>There are several ways to communicate with us:</p> <ul> <li>The <code>#kube-bind</code> channel in the Kubernetes Slack workspace.</li> <li>Our mailing lists:<ul> <li>kube-bind-dev for development discussions.</li> </ul> </li> <li>By joining the kcp-dev mailing list, you should receive an invite to our bi-weekly community meetings.</li> </ul>"},{"location":"contributing/","title":"Contributing to kube-bind","text":"<p>kube-bind is Apache 2.0 licensed and we accept contributions via GitHub pull requests.</p> <p>Please read the following guide if you're interested in contributing to kcp.</p>"},{"location":"contributing/#certificate-of-origin","title":"Certificate of Origin","text":"<p>By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. See the DCO file for details.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ol> <li>Clone this repository.</li> <li>Install Go (currently 1.22).</li> <li>Install kubectl.</li> </ol>"},{"location":"contributing/#finding-areas-to-contribute","title":"Finding Areas to Contribute","text":"<p>Starting to participate in a new project can sometimes be overwhelming, and you may not know where to begin. Fortunately, we are here to help! We track all of our tasks here in GitHub, and we label our issues to categorize them. Here are a couple of handy links to check out:</p> <ul> <li>Good first issue issues</li> <li>Help wanted issues</li> </ul> <p>You're certainly not limited to only these kinds of issues, though! If you're comfortable, please feel free to try working on anything that is open.</p> <p>We do use the assignee feature in GitHub for issues. If you find an unassigned issue, comment asking if you can be assigned, and ideally wait for a maintainer to respond. If you find an assigned issue and you want to work on it or help out, please reach out to the assignee first.</p> <p>Sometimes you might get an amazing idea and start working on a huge amount of code. We love and encourage excitement like this, but we do ask that before you embarking on a giant pull request, please reach out to the community first for an initial discussion. You could file an issue, send a discussion to our mailing list, and/or join one of our community meetings.</p> <p>Finally, we welcome and value all types of contributions, beyond \"just code\"! Other types include triaging bugs, tracking down and fixing flaky tests, improving our documentation, helping answer community questions, proposing and reviewing designs, etc.</p>"},{"location":"contributing/#getting-your-pr-merged","title":"Getting your PR Merged","text":"<p>The <code>kube-bind</code> project uses <code>OWNERS</code> files to denote the collaborators who can assist you in getting your PR merged.  There are two roles: reviewer and approver.  Merging a PR requires sign off from both a reviewer and an approver.</p>"},{"location":"contributing/#community-roles","title":"Community Roles","text":""},{"location":"contributing/#reviewers","title":"Reviewers","text":"<p>Reviewers are responsible for reviewing code for correctness and adherence to standards. Oftentimes reviewers will be able to advise on code efficiency and style as it relates to golang or project conventions as well as other considerations that might not be obvious to the contributor.</p>"},{"location":"contributing/#approvers","title":"Approvers","text":"<p>Approvers are responsible for sign-off on the acceptance of the contribution. In essence, approval indicates that the change is desired and good for the project, aligns with code, api, and system conventions, and appears to follow all required process including adequate testing, documentation, follow ups, or notifications to other areas who might be interested or affected by the change.</p> <p>Approvers are also reviewers.</p>"},{"location":"contributing/#management-of-owners-files","title":"Management of <code>OWNERS</code> Files","text":"<p>If a reviewer or approver no longer wishes to be in their current role it is requested that a PR be opened to update the <code>OWNERS</code> file. <code>OWNERS</code> files may be periodically reviewed and updated based on project activity or feedback to ensure an acceptable contributor experience is maintained.</p>"},{"location":"developers/","title":"Developers","text":""},{"location":"developers/backend/","title":"Backend","text":""},{"location":"developers/backend/http/api-binding/","title":"API Binding","text":""},{"location":"developers/backend/http/api-binding/#overview","title":"Overview","text":"<pre><code>sequenceDiagram\n    autonumber\n    participant consumer-cluster as Consumer cluster\n    participant client as Client\n    participant provider-cluster as Provider cluster\n    participant provider-backend as Provider backend\n\n\n    %% Create APIServiceExportRequest\n    client-&gt;&gt;provider-cluster: Create \"APIServiceExportRequest\"\n\n    par Provider\n      provider-backend-&gt;&gt;provider-cluster: Get \"APIServiceExportRequest\"\n      loop For each \"APIServiceExportRequest.spec.resources\"\n        provider-backend-&gt;&gt;provider-cluster: Create \"APIServiceExport\"\n      end\n      provider-backend-&gt;&gt;provider-cluster: Set \"APIServiceExportRequest.status.phase\"\n    and Client\n      loop Every 1 second for 10 minutes\n      client-&gt;&gt;provider-cluster: Get \"APIServiceExportRequest\"\n      client-&gt;&gt;client: Verify \"APIServiceExportRequest\"&lt;br/&gt;(.status.phase == Succeeded)\"\n      end\n    end\n\n    %% Create APIServiceBindings\n    loop For each \"APIServiceExportRequest.spec.resources\"\n    client-&gt;&gt;consumer-cluster: Create \"APIServiceBinding\"\n    end</code></pre>"},{"location":"developers/backend/http/api-binding/#contracts","title":"Contracts","text":"<p>APIServiceExportRequest</p> <p>In case the APIServiceExportRequest is accepted, the provider backend must ensure that</p> <ul> <li>for each <code>APIServiceExportRequest.spec.resources</code> an <code>APIServiceExport</code> is created</li> <li>each <code>APIServiceExport</code> is created in the namespace of the <code>APIServiceExportRequest</code></li> <li>each <code>APIServiceExport</code> is created with a name following the pattern <code>resource.resource + \".\" + resource.group</code></li> <li>the <code>APIServiceExportRequest.status.phase</code> is set to <code>Succeeded</code></li> </ul> <p>In case the APIServiceExportRequest is declined, the provider backend must ensure that</p> <ul> <li>the <code>APIServiceExportRequest.status.terminalMessage</code> is set to a human readable message describing the reason</li> <li>the <code>APIServiceExportRequest.status.phase</code> is set to <code>Failed</code></li> </ul>"},{"location":"developers/backend/http/cluster-binding/","title":"Cluster Binding","text":""},{"location":"developers/backend/http/cluster-binding/#overview","title":"Overview","text":"<pre><code>sequenceDiagram\n    autonumber\n    participant consumer-cluster as Consumer cluster\n    participant client as Client\n    participant provider-backend as Provider backend\n    participant authentication-provider as Authentication Provider\n\n    %% Get provider information\n    client-&gt;&gt;+provider-backend: GET \"${PROVIDER_BINDING_URL}\"\n    provider-backend-&gt;&gt;-client: 200 \"BindingProvider\"\n\n    client-&gt;&gt;client: Verify \"BindingProvider\"\n\n    %% Authenticate to provider\n    client--&gt;&gt;authentication-provider: Authenticate to provider\n\n    %% Bind to API\n    provider-backend-&gt;&gt;client: 200 \"BindingResponse\"\n\n    client-&gt;&gt;consumer-cluster: Ensure kubeconfig secret\n\n    loop For each \"BindingResponse.requests\"\n    client-&gt;&gt;consumer-cluster: Bind remote API to consumer cluster\n    end</code></pre>"},{"location":"developers/backend/http/cluster-binding/#contracts","title":"Contracts","text":"<p>BindingResponse</p> <p>In case the cluster binding request is accepted, the provider backend must ensure that</p> <ul> <li>the kubeconfig returned in the <code>BindingResponse</code> contains a current context</li> <li>the configured current context points to the \"cluster namespace\"</li> <li>the <code>ClusterBinding</code> object named \"cluster\" exists in the \"cluster namespace\"</li> <li>the secret referenced by <code>ClusterBinding.spec.kubeconfigSecretRef.name</code> exists</li> <li>the key of the secret referenced by <code>ClusterBinding.spec.kubeconfigSecretRef.key</code> contains a valid kubeconfig</li> <li>the configured current context points to a user with at least the following permissions in the \"cluster namespace\" (here expressed as RBAC rules)   <pre><code>- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiserviceexportrequests\"]\n  verbs: [\"create\", \"delete\", \"patch\", \"update\", \"get\", \"list\", \"watch\"]\n\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiserviceexports\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiserviceexports/status\"]\n  verbs: [\"get\", \"patch\", \"update\"]\n\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"apiservicenamespaces\"]\n  verbs: [\"create\", \"delete\", \"patch\", \"update\", \"get\", \"list\", \"watch\"]\n\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"clusterbindings\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"kube-bind.io\"]\n  resources: [\"clusterbindings/status\"]\n  verbs: [\"get\", \"patch\", \"update\"]\n\n- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre></li> </ul>"},{"location":"developers/konnector/","title":"konnector","text":""},{"location":"developers/konnector/controllers/apiservicebinding/","title":"APIServiceBindings","text":"<p>The APIServiceBinding controller watches <code>APIServiceBindings</code> and the referenced <code>Secrets</code> in the consumer cluster.</p> <p>It is responsible for:</p> <ul> <li>validating the kubeconfig stored in the secrets referenced by <code>APIServiceBindings</code></li> </ul>"},{"location":"developers/konnector/controllers/apiservicebinding/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceBinding\"])\n\n    get_kubeconfig_secret([\"Get referenced kubeconfig secret\"])\n    is_kubeconfig_valid{\"kubeconfig&lt;br&gt;valid?\"}\n\n    set_condition_secret_valid_to_true([\"Set condition 'SecretValid' to true\"])\n    set_condition_secret_valid_to_false([\"Set condition 'SecretValid' to false\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_kubeconfig_secret\n    get_kubeconfig_secret --&gt; is_kubeconfig_valid\n\n    is_kubeconfig_valid --&gt; |yes| set_condition_secret_valid_to_true\n    is_kubeconfig_valid --&gt; |no| set_condition_secret_valid_to_false\n\n    set_condition_secret_valid_to_true --&gt; stop\n    set_condition_secret_valid_to_false --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/konnector/","title":"konnector","text":"<p>The konnector implements the main reconciliation loop and watches <code>APIServiceBindings</code> and the referenced <code>Secrets</code> in the consumer cluster.</p> <p>It is responsible for:</p> <ul> <li>starting / stopping a set of controllers per service provider</li> </ul>"},{"location":"developers/konnector/controllers/konnector/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceBinding\"])\n\n    get_kubeconfig_secret([\"Get referenced kubeconfig secret\"])\n    is_kubeconfig_empty{\"kubeconfig&lt;br&gt;empty?\"}\n\n    get_controller_context_for_binding([\"Get controller context for binding\"])\n    is_controller_context_for_binding_present{\"context&lt;br&gt;exists?\"}\n    is_controller_context_current{\"context&lt;br&gt;up-to-date?\"}\n    is_controller_context_used{\"context&lt;br&gt;in use?\"}\n\n    get_controller_context_for_kubeconfig([\"Get controller context for kubeconfig\"])\n    is_controller_context_for_kubeconfig_present{\"context&lt;br&gt;exists?\"}\n\n    create_controller_context_for_binding([\"Create controller context for binding\"])\n    add_binding_to_controller_context([\"Add binding to controller context\"])\n    remove_binding_from_controller_context([\"Remove binding from controller context\"])\n\n    start_controllers([\"Start controllers\"])\n    stop_controllers([\"Stop controllers\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_kubeconfig_secret\n    get_kubeconfig_secret --&gt; get_controller_context_for_binding\n    get_controller_context_for_binding --&gt; is_controller_context_for_binding_present\n\n    is_controller_context_for_binding_present --&gt;|yes| is_controller_context_current\n        is_controller_context_current --&gt;|yes| is_kubeconfig_empty\n        is_controller_context_current --&gt;|no| remove_binding_from_controller_context\n            remove_binding_from_controller_context --&gt; is_controller_context_used\n                is_controller_context_used --&gt;|yes| stop\n                is_controller_context_used --&gt;|no| stop_controllers\n                    stop_controllers --&gt; stop\n\n    is_controller_context_for_binding_present --&gt;|no| is_kubeconfig_empty\n        is_kubeconfig_empty --&gt;|yes| stop\n        is_kubeconfig_empty --&gt;|no| get_controller_context_for_kubeconfig\n            get_controller_context_for_kubeconfig --&gt; is_controller_context_for_kubeconfig_present\n            is_controller_context_for_kubeconfig_present --&gt;|yes| add_binding_to_controller_context\n                add_binding_to_controller_context --&gt; stop\n            is_controller_context_for_kubeconfig_present --&gt;|no| create_controller_context_for_binding\n                create_controller_context_for_binding --&gt; start_controllers\n                start_controllers --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/apiservicebinding/","title":"APIServiceBindings","text":"<p>The APIServiceBinding controller watches <code>APIServiceBindings</code>, and <code>CRDs</code> in the consumer cluster and <code>APIServiceExports</code> in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>synchronizing <code>APIServiceExports</code> in the provider cluster to <code>CRDs</code> in the consumer cluster</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiservicebinding/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceBinding\"])\n\n    is_apiservicebinding_owned{\"binding&lt;br&gt;owned?\"}\n    set_apiservicebinding_condition_connected_to_true([\"Set condition 'Connected' to true\"])\n    set_apiservicebinding_condition_connected_to_false([\"Set condition 'Connected' to false\"])\n    set_apiservicebinding_condition_schemainsync_to_true([\"Set condition 'SchemaInSync' to true\"])\n    set_apiservicebinding_condition_schemainsync_to_false([\"Set condition 'SchemaInSync' to false\"])\n\n    get_apiserviceexport([\"Get APIServiceExport\"])\n    convert_apiserviceexport_to_crd([\"Convert APIServiceExport to CRD\"])\n    is_apiserviceexport_present{\"export&lt;br&gt;exists?\"}\n    is_apiserviceexport_valid{\"export&lt;br&gt;valid?\"}\n\n    get_crd([\"Get CRD\"])\n    create_crd([\"Create CRD\"])\n    update_crd([\"Update CRD\"])\n    is_crd_present{\"CRD&lt;br&gt;exists?\"}\n    is_crd_owned{\"CRD&lt;br&gt;owned?\"}\n\n    get_clusterbinding([\"Get ClusterBinding\"])\n    set_apiservicebinding_provider_name([\"Set provider name\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; is_apiservicebinding_owned\n\n    is_apiservicebinding_owned --&gt; |yes| get_apiserviceexport\n    get_apiserviceexport --&gt; is_apiserviceexport_present\n    is_apiserviceexport_present --&gt; |yes| set_apiservicebinding_condition_connected_to_true\n    is_apiserviceexport_present --&gt; |no| set_apiservicebinding_condition_connected_to_false\n    set_apiservicebinding_condition_connected_to_true --&gt; convert_apiserviceexport_to_crd\n    set_apiservicebinding_condition_connected_to_false --&gt; stop\n\n    convert_apiserviceexport_to_crd --&gt; is_apiserviceexport_valid\n    is_apiserviceexport_valid --&gt; |yes| get_crd\n    is_apiserviceexport_valid --&gt; |no| set_apiservicebinding_condition_schemainsync_to_false\n\n    get_crd --&gt; is_crd_present\n    is_crd_present --&gt; |no| create_crd\n    is_crd_present --&gt; |yes| is_crd_owned\n    update_crd --&gt; set_apiservicebinding_condition_schemainsync_to_true\n    create_crd --&gt; set_apiservicebinding_condition_schemainsync_to_true\n\n    is_crd_owned --&gt; |yes| update_crd\n    is_crd_owned --&gt; |no| set_apiservicebinding_condition_schemainsync_to_false\n\n    set_apiservicebinding_condition_schemainsync_to_true --&gt; get_clusterbinding\n    set_apiservicebinding_condition_schemainsync_to_false --&gt; get_clusterbinding\n\n    get_clusterbinding --&gt; set_apiservicebinding_provider_name\n\n    is_apiservicebinding_owned --&gt; |no| stop\n    set_apiservicebinding_provider_name --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/apiserviceexport/","title":"APIServiceExports","text":"<p>The APIServiceExport controller watches <code>APIServiceExports</code> and the referenced <code>CustomResourceDefinitions</code> (CRDs) in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>Ensuring the existence and validity of <code>APIServiceExports</code>.</li> <li>Managing the lifecycle of <code>APIServiceExports</code> by starting and stopping spec and status syncers and controllers.</li> <li>Checking <code>APIServiceBinding</code> condition and setting <code>ConsumerInSync</code> condition in <code>APIServiceExport</code></li> <li>Copying conditions from the referenced CRDs to the <code>APIServiceExport</code> status.</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiserviceexport/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call\n    for APIServiceExport\"])\n    is_apiserviceexport_present{\"APIServiceExport&lt;br&gt;exists?\"}\n\n    get_crd([\"Get referenced\n    CustomResourceDefinition\"])\n    get_crd2([\"Get referenced\n    CustomResourceDefinition\"])\n\n    is_crd_present{\"CRD&lt;br&gt;exists?\"}\n    is_crd_present2{\"CRD&lt;br&gt;exists?\"}\n\n    stop_apiserviceexport_sync([\"Stop APIServiceExport sync\"])\n\n    get_binding([\"Get referenced\n    APIServiceBinding\"])\n    get_binding2([\"Get referenced APIServiceBinding\"])\n\n    is_binding_present{\"APIServiceBinding&lt;br&gt;exists?\"}\n    is_binding_present2{\"APIServiceBinding&lt;br&gt;exists?\"}\n\n    is_binding_schemainsync{\"APIServiceBinding&lt;br&gt;has SchemaInSync?\"}\n    start_new_syncer([\"Start new syncer\"])\n\n    set_apiserviceexport_condition_connected_to_true([\"Set condition\n    'Connected' to true\"])\n    set_apiserviceexport_condition_connected_to_false([\"Set\n    condition 'Connected'\nto false\"])\n    set_apiserviceexport_condition_consumerinsync_to_true([\"Set condition\n    'ConsumerInSync' to true\"])\n    set_apiserviceexport_condition_consumerinsync_to_false([\"Set condition\n    'ConsumerInSync' to false\"])\n\n    copy_crd_conditions([\"Copy CRD conditions\n    to APIServiceExport\n    conditions\"])\n    set_summary_condition([\"Set summary\n    of all conditions\n    on APIServiceExport\"])\n\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; is_apiserviceexport_present\n    is_apiserviceexport_present --&gt; |no| stop\n    is_apiserviceexport_present --&gt; |yes| get_crd\n    get_crd --&gt; is_crd_present\n    is_crd_present --&gt; |yes| get_binding\n    is_crd_present --&gt; |no| stop_apiserviceexport_sync\n    stop_apiserviceexport_sync --&gt; stop\n\n    get_binding --&gt; is_binding_present\n    is_binding_present --&gt; |yes| start_new_syncer\n    is_binding_present --&gt; |no| stop_apiserviceexport_sync\n    stop_apiserviceexport_sync --&gt; stop\n\n    start_new_syncer --&gt; get_binding2\n    get_binding2 --&gt; is_binding_present2\n    is_binding_present2 --&gt; |yes| set_apiserviceexport_condition_connected_to_true\n    is_binding_present2 --&gt; |no| set_apiserviceexport_condition_connected_to_false\n    set_apiserviceexport_condition_connected_to_false --&gt; set_apiserviceexport_condition_consumerinsync_to_false\n    set_apiserviceexport_condition_connected_to_true --&gt; is_binding_schemainsync\n    is_binding_schemainsync --&gt; |yes| set_apiserviceexport_condition_consumerinsync_to_true\n    set_apiserviceexport_condition_consumerinsync_to_true --&gt; get_crd2\n    is_binding_schemainsync --&gt; |no| set_apiserviceexport_condition_consumerinsync_to_false\n    set_apiserviceexport_condition_consumerinsync_to_false --&gt; get_crd2\n\n    get_crd2 --&gt; is_crd_present2\n    is_crd_present2 --&gt; |no| stop\n    is_crd_present2 --&gt; |yes| copy_crd_conditions\n    copy_crd_conditions --&gt; set_summary_condition\n    set_summary_condition --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/apiservicenamespace/","title":"APIServiceNamespaces","text":"<p>The APIServiceNamespace controller watches <code>Namespaces</code> in the consumer cluster and <code>APIServiceNamespaces</code> in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>synchronizing <code>Namespaces</code> in the consumer cluster with <code>APIServiceNamespaces</code> in the provider cluster</li> </ul>"},{"location":"developers/konnector/controllers/cluster/apiservicenamespace/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for APIServiceNamespace\"])\n\n    get_namespace([\"Get associated namespace\"])\n    is_namespace_present([\"namespace&lt;br&gt;exists?\"])\n\n    delete_api_service_namespace([\"Delete APIServiceNamespace\"])\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_namespace\n    get_namespace --&gt; is_namespace_present\n\n    is_namespace_present --&gt; |yes| stop\n    is_namespace_present --&gt; |no| delete_api_service_namespace\n    delete_api_service_namespace --&gt; stop</code></pre>"},{"location":"developers/konnector/controllers/cluster/clusterbinding/","title":"ClusterBindings","text":"<p>The ClusterBinding controller watches <code>Secrets</code> (referenced by <code>APIServiceBindings</code>) in the consumer cluster and <code>ClusterBindings</code>, the referenced <code>Secrets</code>, and <code>APIServiceExport</code> in the provider cluster.</p> <p>It is responsible for:</p> <ul> <li>synchronizing the secret referenced by the <code>ClusterBinding</code> in the provider cluster to the secret referenced by the <code>APIServiceBindings</code> in the consumer cluster</li> <li>reporting heartbeat to <code>ClusterBinding</code> in the provider cluster</li> <li>reporting konnector version <code>ClusterBinding</code> in the provider cluster</li> <li>reporting heartbeat to all <code>APIServiceBindings</code> managed by <code>ClusterBinding</code> in the consumer cluster</li> </ul>"},{"location":"developers/konnector/controllers/cluster/clusterbinding/#overview","title":"Overview","text":"<pre><code>flowchart TD\n    %% Nodes\n    start@{ shape: start }\n    stop@{ shape: stop }\n\n    enqueue_reconcile([\"Enqueue reconcile call for ClusterBinding\"])\n\n    update_cluster_binding([\"Update ClusterBinding\"])\n    is_cluster_binding_update_successful{\"update&lt;br&gt;successful?\"}\n\n    get_cluster_binding_kubeconfig_secret([\"Get referenced provider kubeconfig secret\"])\n    is_cluster_binding_kubeconfig_secret_valid{\"secret&lt;br&gt;valid?\"}\n\n    set_cluster_binding_condition_secret_valid_to_true([\"Set condition 'SecretValid' to true\"])\n    set_cluster_binding_condition_secret_valid_to_false([\"Set condition 'SecretValid' to false\"])\n    set_cluster_binding_condition_valid_version_to_true([\"Set condition 'ValidVersion' to true\"])\n    set_cluster_binding_condition_valid_version_to_false([\"Set condition 'ValidVersion' to false\"])\n    set_cluster_binding_condition_ready([\"Set condition 'Ready' to summary\"])\n\n    set_cluster_binding_status_last_heartbeat([\"Set status 'LastHeartbeatTime' to now\"])\n    set_cluster_binding_status_konnector_version([\"Set status 'KonnectorVersion'\"])\n\n    get_api_binding_kubeconfig_secret([\"Get consumer kubeconfig secret\"])\n    create_api_binding_kubeconfig_secret([\"Create consumer kubeconfig secret\"])\n    update_api_binding_kubeconfig_secret([\"Update consumer kubeconfig secret\"])\n    is_api_binding_kubeconfig_secret_present{\"secret&lt;br&gt;exists?\"}\n\n    set_api_binding_status_heartbeating_to_true([\"Set APIServiceBinding conditions 'Heartbeating' to true\"])\n    set_api_binding_status_heartbeating_to_false([\"Set APIServiceBinding conditions 'Heartbeating' to false\"])\n\n    get_konnector_version([\"Get konnector version\"])\n    is_konnector_version_valid{\"version&lt;br&gt;valid?\"}\n\n    %% Transitions\n    start --&gt; enqueue_reconcile\n    enqueue_reconcile --&gt; get_cluster_binding_kubeconfig_secret\n    get_cluster_binding_kubeconfig_secret --&gt; is_cluster_binding_kubeconfig_secret_valid\n\n    is_cluster_binding_kubeconfig_secret_valid --&gt; |yes| get_api_binding_kubeconfig_secret\n        get_api_binding_kubeconfig_secret --&gt; is_api_binding_kubeconfig_secret_present\n        is_api_binding_kubeconfig_secret_present --&gt; |yes| update_api_binding_kubeconfig_secret\n        is_api_binding_kubeconfig_secret_present --&gt; |no| create_api_binding_kubeconfig_secret\n        update_api_binding_kubeconfig_secret --&gt; set_cluster_binding_condition_secret_valid_to_true\n        create_api_binding_kubeconfig_secret --&gt; set_cluster_binding_condition_secret_valid_to_true\n\n    is_cluster_binding_kubeconfig_secret_valid --&gt; |no| set_cluster_binding_condition_secret_valid_to_false\n\n    set_cluster_binding_condition_secret_valid_to_true --&gt; set_cluster_binding_status_last_heartbeat\n    set_cluster_binding_condition_secret_valid_to_false --&gt; set_cluster_binding_status_last_heartbeat\n\n    set_cluster_binding_status_last_heartbeat --&gt; get_konnector_version\n    get_konnector_version --&gt; is_konnector_version_valid\n\n    is_konnector_version_valid --&gt; |yes| set_cluster_binding_status_konnector_version\n        set_cluster_binding_status_konnector_version --&gt; set_cluster_binding_condition_valid_version_to_true\n\n    is_konnector_version_valid --&gt; |no| set_cluster_binding_condition_valid_version_to_false\n\n    set_cluster_binding_condition_valid_version_to_true --&gt; set_cluster_binding_condition_ready\n    set_cluster_binding_condition_valid_version_to_false --&gt; set_cluster_binding_condition_ready\n\n    set_cluster_binding_condition_ready --&gt; update_cluster_binding\n    update_cluster_binding --&gt; is_cluster_binding_update_successful\n\n    is_cluster_binding_update_successful --&gt; |yes| set_api_binding_status_heartbeating_to_true\n    is_cluster_binding_update_successful --&gt; |no| set_api_binding_status_heartbeating_to_false\n\n    set_api_binding_status_heartbeating_to_true --&gt; stop\n    set_api_binding_status_heartbeating_to_false --&gt; stop</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>This chapter provides automatically generated references for the kube-bind <code>kubectl</code> plugin and APIs included in kube-bind.</p>"},{"location":"reference/cli/bind/","title":"bind","text":""},{"location":"reference/cli/bind/#synopsis","title":"Synopsis","text":"<p>kube-bind is a project that aims to provide better support for service providers and consumers that reside in distinct Kubernetes clusters.</p> <p>For more information, see: https://kube-bind.io</p> <p>To bind a remote service, use the 'kubectl bind' command. Please check the examples below for more information.</p> <pre><code>bind [flags]\n</code></pre>"},{"location":"reference/cli/bind/#examples","title":"Examples","text":"<pre><code>    # select a kube-bind.io compatible service from the given URL, e.g. an API service.\n    kubectl bind https://mangodb.com/exports\n\n    # authenticate and configure the services to bind, but don't actually bind them.\n    kubectl bind https://mangodb.com/exports --dry-run -o yaml &gt; apiservice-export-requests.yaml\n\n    # bind to a remote API service as configured above and actually bind to it, e.g. in GitOps automation.\n    kubectl bind apiservice --remote-kubeconfig name -f apiservice-binding-requests.yaml\n\n    # bind to a remote API service via a request manifest from a https URL.\n    kubectl bind apiservice --remote-kubeconfig name https://some-url.com/apiservice-export-requests.yaml\n</code></pre>"},{"location":"reference/cli/bind/#options","title":"Options","text":"<pre><code>      --add_dir_header                       If true, adds the file directory to the header of the log messages\n      --allow-missing-template-keys          If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats. (default true)\n      --alsologtostderr                      log to standard error as well as files (no effect when -logtostderr=true)\n      --as-uid string                        UID to impersonate for the operation\n      --certificate-authority string         Path to a cert file for the certificate authority\n      --context string                       The name of the kubeconfig context to use\n      --disable-compression                  If true, opt-out of response compression for all requests to the server\n  -d, --dry-run                              If true, only print the requests that would be sent to the service provider after authentication, without actually binding.\n  -h, --help                                 help for bind\n      --insecure-skip-tls-verify             Skip the verification of the server's certificate chain and host name.\n      --konnector-image string               The konnector image to use\n      --kubeconfig string                    path to the kubeconfig file\n      --log-flush-frequency duration         Maximum number of seconds between log flushes (default 5s)\n      --log-text-info-buffer-size quantity   [Alpha] In text format with split output streams, the info messages can be buffered for a while to increase performance. The default value of zero bytes disables buffering. The size can be specified as number of bytes (512), multiples of 1000 (1K), multiples of 1024 (2Ki), or powers of those (3M, 4G, 5Mi, 6Gi). Enable the LoggingAlphaOptions feature gate to use this.\n      --log-text-split-stream                [Alpha] In text format, write error messages to stderr and info messages to stdout. The default is to write a single stream to stdout. Enable the LoggingAlphaOptions feature gate to use this.\n      --log_backtrace_at traceLocation       when logging hits line file:N, emit a stack trace (default :0)\n      --log_dir string                       If non-empty, write log files in this directory (no effect when -logtostderr=true)\n      --log_file string                      If non-empty, use this log file (no effect when -logtostderr=true)\n      --log_file_max_size uint               Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800)\n      --logging-format string                Sets the log format. Permitted formats: \"text\". (default \"text\")\n      --logtostderr                          log to standard error instead of files (default true)\n  -n, --namespace string                     If present, the namespace scope for this CLI request\n      --one_output                           If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true)\n  -o, --output string                        Output format. One of: (json, yaml, name, go-template, go-template-file, template, templatefile, jsonpath, jsonpath-as-json, jsonpath-file). (default \"yaml\")\n      --password string                      Password for basic authentication to the API server\n      --proxy-url string                     If provided, this URL will be used to connect via proxy\n      --server string                        The address and port of the Kubernetes API server\n      --show-managed-fields                  If true, keep the managedFields when printing objects in JSON or YAML format.\n      --skip-konnector                       Skip the deployment of the konnector\n      --skip_headers                         If true, avoid header prefixes in the log messages\n      --skip_log_headers                     If true, avoid headers when opening log files (no effect when -logtostderr=true)\n      --stderrthreshold severity             logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=true) (default 2)\n      --template string                      Template string or path to template file to use when -o=go-template, -o=go-template-file. The template format is golang templates [http://golang.org/pkg/text/template/#pkg-overview].\n      --tls-server-name string               If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                         Bearer token for authentication to the API server\n      --user string                          The name of the kubeconfig user to use\n      --username string                      Username for basic authentication to the API server\n  -v, --v Level                              number for the log level verbosity\n      --vmodule pattern=N,...                comma-separated list of pattern=N settings for file-filtered logging (only works for text log format)\n</code></pre>"},{"location":"reference/cli/bind/#see-also","title":"SEE ALSO","text":"<ul> <li>bind apiservice    - Bind to a remote API service</li> </ul>"},{"location":"reference/cli/bind_apiservice/","title":"bind apiservice","text":"<pre><code>bind apiservice https://&lt;url-to-a-APIServiceExportRequest&gt;|-f &lt;file-to-a-APIBindingRequest&gt; [flags]\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#examples","title":"Examples","text":"<pre><code>    # bind to a remote API service. Use kubectl bind to create the APIServiceExportRequest interactively.\n    kubectl bind apiservice --remote-kubeconfig file -f apiservice-export-request.yaml\n\n    # bind to a remote API service via a request manifest from a https URL.\n    kubectl bind apiservice --remote-kubeconfig file https://some-url.com/apiservice-export-requests.yaml\n\n    # bind to a API service directly without any remote agent or service provider.\n    kubectl bind apiservice --remote-kubeconfig file -n remote-namespace resources.group/v1\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#options","title":"Options","text":"<pre><code>      --allow-missing-template-keys          If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats. (default true)\n      --as-uid string                        UID to impersonate for the operation\n      --certificate-authority string         Path to a cert file for the certificate authority\n      --context string                       The name of the kubeconfig context to use\n      --disable-compression                  If true, opt-out of response compression for all requests to the server\n      --downgrade-konnector                  Downgrade the konnector to the version of the kubectl-bind-apiservice binary\n  -f, --file string                          A file with an APIServiceExportRequest manifest. Use - to read from stdin\n  -h, --help                                 help for apiservice\n      --insecure-skip-tls-verify             If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string                    path to the kubeconfig file\n      --log-flush-frequency duration         Maximum number of seconds between log flushes (default 5s)\n      --log-text-info-buffer-size quantity   [Alpha] In text format with split output streams, the info messages can be buffered for a while to increase performance. The default value of zero bytes disables buffering. The size can be specified as number of bytes (512), multiples of 1000 (1K), multiples of 1024 (2Ki), or powers of those (3M, 4G, 5Mi, 6Gi). Enable the LoggingAlphaOptions feature gate to use this.\n      --log-text-split-stream                [Alpha] In text format, write error messages to stderr and info messages to stdout. The default is to write a single stream to stdout. Enable the LoggingAlphaOptions feature gate to use this.\n      --logging-format string                Sets the log format. Permitted formats: \"text\". (default \"text\")\n  -n, --namespace string                     If present, the namespace scope for this CLI request\n  -o, --output string                        Output format. One of: (json, yaml, name, go-template, go-template-file, template, templatefile, jsonpath, jsonpath-as-json, jsonpath-file).\n      --password string                      Password for basic authentication to the API server\n      --proxy-url string                     If provided, this URL will be used to connect via proxy\n      --remote-kubeconfig string             A file path for a kubeconfig file to connect to the service provider cluster\n      --remote-kubeconfig-name string        The name of the remote kubeconfig secret to read from\n      --remote-kubeconfig-namespace string   The namespace of the remote kubeconfig secret to read from\n      --remote-namespace string              The namespace in the remote cluster where the konnector is deployed\n      --server string                        The address and port of the Kubernetes API server\n      --show-managed-fields                  If true, keep the managedFields when printing objects in JSON or YAML format.\n      --skip-konnector                       Skip the deployment of the konnector\n      --template string                      Template string or path to template file to use when -o=go-template, -o=go-template-file. The template format is golang templates [http://golang.org/pkg/text/template/#pkg-overview].\n      --tls-server-name string               If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                         Bearer token for authentication to the API server\n      --user string                          The name of the kubeconfig user to use\n      --username string                      Username for basic authentication to the API server\n  -v, --v Level                              number for the log level verbosity\n      --vmodule pattern=N,...                comma-separated list of pattern=N settings for file-filtered logging (only works for text log format)\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --add_dir_header                   If true, adds the file directory to the header of the log messages\n      --alsologtostderr                  log to standard error as well as files (no effect when -logtostderr=true)\n      --log_backtrace_at traceLocation   when logging hits line file:N, emit a stack trace (default :0)\n      --log_dir string                   If non-empty, write log files in this directory (no effect when -logtostderr=true)\n      --log_file string                  If non-empty, use this log file (no effect when -logtostderr=true)\n      --log_file_max_size uint           Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800)\n      --logtostderr                      log to standard error instead of files (default true)\n      --one_output                       If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true)\n      --skip_headers                     If true, avoid header prefixes in the log messages\n      --skip_log_headers                 If true, avoid headers when opening log files (no effect when -logtostderr=true)\n      --stderrthreshold severity         logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=true) (default 2)\n</code></pre>"},{"location":"reference/cli/bind_apiservice/#see-also","title":"SEE ALSO","text":"<ul> <li>bind  - kubectl plugin for Kube-Bind.io, bind different remote types into the current cluster.</li> </ul>"},{"location":"reference/crd/kube-bind.io/apiservicebindings/","title":"APIServiceBinding","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#apiservicebinding-crd-schema-reference-group-kube-bindio","title":"APIServiceBinding CRD schema reference (group kube-bind.io)","text":"APIServiceBinding binds an API service represented by a APIServiceExport in a service provider cluster into a consumer cluster. This object lives in the consumer cluster.  Full name: apiservicebindings.kube-bind.io Group: kube-bind.io Singular name: apiservicebinding Plural name: apiservicebindings Scope: Cluster Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>Namespace of the referent.</p> object <p>status contains reconciliation information for a service binding.</p> array <p>conditions is a list of conditions that apply to the APIServiceBinding.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different APIServiceBindings.</p>"},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.spec.kubeconfigSecretRef.namespace","title":".spec.kubeconfigSecretRef.namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha1-.status.providerPrettyName","title":".status.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>Namespace of the referent.</p> object <p>status contains reconciliation information for a service binding.</p> array <p>BoundSchemas contains references to all BoundAPIResourceSchema objects associated with this APIServiceBinding, tracking consumer usage status.</p> object <p>BoundSchemaReference contains a reference to a BoundAPIResourceSchema with status information.</p> string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>conditions is a list of conditions that apply to the APIServiceBinding.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different APIServiceBindings.</p>"},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.spec.kubeconfigSecretRef.namespace","title":".spec.kubeconfigSecretRef.namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas","title":".status.boundSchemas","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas[*]","title":".status.boundSchemas[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas[*].group","title":".status.boundSchemas[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.boundSchemas[*].resource","title":".status.boundSchemas[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiservicebindings/#v1alpha2-.status.providerPrettyName","title":".status.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/","title":"APIServiceExportRequest","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#apiserviceexportrequest-crd-schema-reference-group-kube-bindio","title":"APIServiceExportRequest CRD schema reference (group kube-bind.io)","text":"APIServiceExportRequest is represents a request session of kubectl-bind-apiservice.  The service provider can prune these objects after some time.  Full name: apiserviceexportrequests.kube-bind.io Group: kube-bind.io Singular name: apiserviceexportrequest Plural name: apiserviceexportrequests Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object <p>parameters holds service provider specific parameters for this binding request.</p> array Required <p>resources is a list of resources that should be exported.</p> object string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>versions is a list of versions that should be exported. If this is empty a sensible default is chosen by the service provider.</p> string object <p>status contains reconciliation information for a service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>phase is the current phase of the binding request. It starts in Pending and transitions to Succeeded or Failed. See the condition for detailed information.</p> string <p>terminalMessage is a human readable message that describes the reason for the current phase.</p>"},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.parameters","title":".spec.parameters","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources","title":".spec.resources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*]","title":".spec.resources[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].group","title":".spec.resources[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].resource","title":".spec.resources[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].versions","title":".spec.resources[*].versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.spec.resources[*].versions[*]","title":".spec.resources[*].versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.phase","title":".status.phase","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha1-.status.terminalMessage","title":".status.terminalMessage","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies how an API service from a service provider should be bound in the local consumer cluster.</p> object <p>parameters holds service provider specific parameters for this binding request.</p> array Required <p>resources is a list of resources that should be exported.</p> object string <p>group is the name of an API group. For core groups this is the empty string \u2018\u201c\u201d\u2019.</p> string Required <p>resource is the name of the resource. Note: it is worth noting that you can not ask for permissions for resource provided by a CRD not provided by an service binding export.</p> array <p>versions is a list of versions that should be exported. If this is empty a sensible default is chosen by the service provider.</p> string object <p>status contains reconciliation information for a service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>phase is the current phase of the binding request. It starts in Pending and transitions to Succeeded or Failed. See the condition for detailed information.</p> string <p>terminalMessage is a human readable message that describes the reason for the current phase.</p>"},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.parameters","title":".spec.parameters","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources","title":".spec.resources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*]","title":".spec.resources[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].group","title":".spec.resources[*].group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].resource","title":".spec.resources[*].resource","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].versions","title":".spec.resources[*].versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.spec.resources[*].versions[*]","title":".spec.resources[*].versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.phase","title":".status.phase","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexportrequests/#v1alpha2-.status.terminalMessage","title":".status.terminalMessage","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/","title":"APIServiceExport","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#apiserviceexport-crd-schema-reference-group-kube-bindio","title":"APIServiceExport CRD schema reference (group kube-bind.io)","text":"APIServiceExport specifies the resource to be exported. It is mostly a CRD: - the spec is a CRD spec, but without webhooks - the status reflects that on the consumer cluster  Full name: apiserviceexports.kube-bind.io Group: kube-bind.io Singular name: apiserviceexport Plural name: apiserviceexports Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies the resource.</p> string <p>ClusterScopedIsolation specifies how cluster scoped service objects are isolated between multiple consumers on the provider side. It can be \u201cPrefixed\u201d, \u201cNamespaced\u201d, or \u201cNone\u201d.</p> string Required <p>group is the API group of the defined custom resource. Empty string means the core API group.     The resources are served under <code>/apis/&lt;group&gt;/...</code> or <code>/api</code> for the core group.</p> string Required <p>informerScope is the scope of the APIServiceExport. It can be either Cluster or Namespace.</p> <p>Cluster:    The konnector has permission to watch all namespaces at once and cluster-scoped resources.             This is more efficient than watching each namespace individually. Namespaced: The konnector has permission to watch only single namespaces.             This is more resource intensive. And it means cluster-scoped resources cannot be exported.</p> object Required <p>names specify the resource and kind names for the custom resource.</p> array <p>categories is a list of grouped resources this custom resource belongs to (e.g. \u2018all\u2019). This is published in API discovery documents, and used by clients to support invocations like <code>kubectl get all</code>.</p> string string Required <p>kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the <code>kind</code> attribute in API calls.</p> string <p>listKind is the serialized kind of the list for this resource. Defaults to \u201c<code>kind</code>List\u201d.</p> string Required <p>plural is the plural name of the resource to serve. The custom resources are served under <code>/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;</code>. Must match the name of the CustomResourceDefinition (in the form <code>&lt;names.plural&gt;.&lt;group&gt;</code>). Must be all lowercase.</p> array <p>shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like <code>kubectl get &lt;shortname&gt;</code>. It must be all lowercase.</p> string string <p>singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased <code>kind</code>.</p> string Required <p>scope indicates whether the defined custom resource is cluster- or namespace-scoped. Allowed values are <code>Cluster</code> and <code>Namespaced</code>.</p> array Required <p>versions is the API version of the defined custom resource.</p> <p>Note: the OpenAPI v3 schemas must be equal for all versions until CEL       version migration is supported.</p> object <p>APIServiceExportVersion describes one API version of a resource.</p> array <p>additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If no columns are specified, a single column displaying the age of the custom resource is used.</p> object <p>CustomResourceColumnDefinition specifies a column for server side printing.</p> string <p>description is a human readable description of this column.</p> string <p>format is an optional OpenAPI type definition for this column. The \u2018name\u2019 format is applied to the primary identifier column to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.</p> string Required <p>jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against each custom resource to produce the value for this column.</p> string Required <p>name is a human readable name for the column.</p> integer <p>priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a priority greater than 0.</p> string Required <p>type is an OpenAPI type definition for this column. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.</p> boolean <p>deprecated indicates this version of the custom resource API is deprecated. When set to true, API requests to this version receive a warning header in the server response. Defaults to false.</p> string <p>deprecationWarning overrides the default warning returned to API clients. May only be set when <code>deprecated</code> is true. The default warning indicates this version is deprecated and recommends use of the newest served version of equal or greater stability, if one exists.</p> string Required <p>name is the version name, e.g. \u201cv1\u201d, \u201cv2beta1\u201d, etc. The custom resources are served under this version at <code>/apis/&lt;group&gt;/&lt;version&gt;/...</code> if <code>served</code> is true.</p> object Required <p>schema describes the structural schema used for validation, pruning, and defaulting of this version of the custom resource.</p> object Required <p>openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.</p> boolean Required <p>served is a flag enabling/disabling this version from being served via REST APIs</p> boolean Required <p>storage indicates this version should be used when persisting custom resources to storage. There must be exactly one version with storage=true.</p> object <p>subresources specify what subresources this version of the defined custom resource have.</p> object <p>scale indicates the custom resource should serve a <code>/scale</code> subresource that returns an <code>autoscaling/v1</code> Scale object.</p> string <p>labelSelectorPath defines the JSON path inside of a custom resource that corresponds to Scale <code>status.selector</code>. Only JSON paths without the array notation are allowed. Must be a JSON Path under <code>.status</code> or <code>.spec</code>. Must be set to work with HorizontalPodAutoscaler. The field pointed by this JSON path must be a string field (not a complex selector struct) which contains a serialized label selector in string form. More info: https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource If there is no value under the given path in the custom resource, the <code>status.selector</code> value in the <code>/scale</code> subresource will default to the empty string.</p> string Required <p>specReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale <code>spec.replicas</code>. Only JSON paths without the array notation are allowed. Must be a JSON Path under <code>.spec</code>. If there is no value under the given path in the custom resource, the <code>/scale</code> subresource will return an error on GET.</p> string Required <p>statusReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale <code>status.replicas</code>. Only JSON paths without the array notation are allowed. Must be a JSON Path under <code>.status</code>. If there is no value under the given path in the custom resource, the <code>status.replicas</code> value in the <code>/scale</code> subresource will default to 0.</p> object <p>status indicates the custom resource should serve a <code>/status</code> subresource. When enabled: 1. requests to the custom resource primary endpoint ignore changes to the <code>status</code> stanza of the object. 2. requests to the custom resource <code>/status</code> subresource ignore changes to anything other than the <code>status</code> stanza of the object.</p> object <p>status contains reconciliation information for the resource.</p> object <p>acceptedNames are the names that are actually being used to serve discovery. They may be different than the names in spec.</p> array <p>categories is a list of grouped resources this custom resource belongs to (e.g. \u2018all\u2019). This is published in API discovery documents, and used by clients to support invocations like <code>kubectl get all</code>.</p> string string Required <p>kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the <code>kind</code> attribute in API calls.</p> string <p>listKind is the serialized kind of the list for this resource. Defaults to \u201c<code>kind</code>List\u201d.</p> string Required <p>plural is the plural name of the resource to serve. The custom resources are served under <code>/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;</code>. Must match the name of the CustomResourceDefinition (in the form <code>&lt;names.plural&gt;.&lt;group&gt;</code>). Must be all lowercase.</p> array <p>shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like <code>kubectl get &lt;shortname&gt;</code>. It must be all lowercase.</p> string string <p>singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased <code>kind</code>.</p> array <p>conditions is a list of conditions that apply to the APIServiceExport. It is updated by the konnector on the consumer cluster.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> array <p>storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from <code>spec.versions</code> while they exist in this list.</p> string"},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.clusterScopedIsolation","title":".spec.clusterScopedIsolation","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.group","title":".spec.group","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.informerScope","title":".spec.informerScope","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names","title":".spec.names","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.categories","title":".spec.names.categories","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.categories[*]","title":".spec.names.categories[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.kind","title":".spec.names.kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.listKind","title":".spec.names.listKind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.plural","title":".spec.names.plural","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.shortNames","title":".spec.names.shortNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.shortNames[*]","title":".spec.names.shortNames[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.names.singular","title":".spec.names.singular","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.scope","title":".spec.scope","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions","title":".spec.versions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*]","title":".spec.versions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns","title":".spec.versions[*].additionalPrinterColumns","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*]","title":".spec.versions[*].additionalPrinterColumns[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].description","title":".spec.versions[*].additionalPrinterColumns[*].description","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].format","title":".spec.versions[*].additionalPrinterColumns[*].format","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].jsonPath","title":".spec.versions[*].additionalPrinterColumns[*].jsonPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].name","title":".spec.versions[*].additionalPrinterColumns[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].priority","title":".spec.versions[*].additionalPrinterColumns[*].priority","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].additionalPrinterColumns[*].type","title":".spec.versions[*].additionalPrinterColumns[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].deprecated","title":".spec.versions[*].deprecated","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].deprecationWarning","title":".spec.versions[*].deprecationWarning","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].name","title":".spec.versions[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].schema","title":".spec.versions[*].schema","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].schema.openAPIV3Schema","title":".spec.versions[*].schema.openAPIV3Schema","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].served","title":".spec.versions[*].served","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].storage","title":".spec.versions[*].storage","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources","title":".spec.versions[*].subresources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale","title":".spec.versions[*].subresources.scale","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale.labelSelectorPath","title":".spec.versions[*].subresources.scale.labelSelectorPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale.specReplicasPath","title":".spec.versions[*].subresources.scale.specReplicasPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.scale.statusReplicasPath","title":".spec.versions[*].subresources.scale.statusReplicasPath","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.spec.versions[*].subresources.status","title":".spec.versions[*].subresources.status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames","title":".status.acceptedNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.categories","title":".status.acceptedNames.categories","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.categories[*]","title":".status.acceptedNames.categories[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.kind","title":".status.acceptedNames.kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.listKind","title":".status.acceptedNames.listKind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.plural","title":".status.acceptedNames.plural","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.shortNames","title":".status.acceptedNames.shortNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.shortNames[*]","title":".status.acceptedNames.shortNames[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.acceptedNames.singular","title":".status.acceptedNames.singular","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.storedVersions","title":".status.storedVersions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha1-.status.storedVersions[*]","title":".status.storedVersions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec specifies the resource.</p> string <p>ClusterScopedIsolation specifies how cluster scoped service objects are isolated between multiple consumers on the provider side. It can be \u201cPrefixed\u201d, \u201cNamespaced\u201d, or \u201cNone\u201d.</p> string Required <p>informerScope is the scope of the APIServiceExport. It can be either Cluster or Namespace.</p> <p>Cluster:    The konnector has permission to watch all namespaces at once and cluster-scoped resources.             This is more efficient than watching each namespace individually. Namespaced: The konnector has permission to watch only single namespaces.             This is more resource intensive. And it means cluster-scoped resources cannot be exported.</p> array Required <p>resources specifies the API resources to export</p> object <p>APIResourceSchemaReference is a list of references to APIResourceSchemas.</p> string Required <p>Name is the name of the resource to export</p> string Required <p>Type of the resource to export Currently only APIResourceSchema is supported</p> object <p>status contains reconciliation information for the resource.</p> object <p>acceptedNames are the names that are actually being used to serve discovery. They may be different than the names in spec.</p> array <p>categories is a list of grouped resources this custom resource belongs to (e.g. \u2018all\u2019). This is published in API discovery documents, and used by clients to support invocations like <code>kubectl get all</code>.</p> string string Required <p>kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the <code>kind</code> attribute in API calls.</p> string <p>listKind is the serialized kind of the list for this resource. Defaults to \u201c<code>kind</code>List\u201d.</p> string Required <p>plural is the plural name of the resource to serve. The custom resources are served under <code>/apis/&lt;group&gt;/&lt;version&gt;/.../&lt;plural&gt;</code>. Must match the name of the CustomResourceDefinition (in the form <code>&lt;names.plural&gt;.&lt;group&gt;</code>). Must be all lowercase.</p> array <p>shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like <code>kubectl get &lt;shortname&gt;</code>. It must be all lowercase.</p> string string <p>singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased <code>kind</code>.</p> array <p>conditions is a list of conditions that apply to the APIServiceExport. It is updated by the konnector on the consumer cluster.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> array <p>storedVersions lists all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so a migration controller can finish a migration to another version (ensuring no old objects are left in storage), and then remove the rest of the versions from this list. Versions may not be removed from <code>spec.versions</code> while they exist in this list.</p> string"},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.clusterScopedIsolation","title":".spec.clusterScopedIsolation","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.informerScope","title":".spec.informerScope","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources","title":".spec.resources","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*]","title":".spec.resources[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*].name","title":".spec.resources[*].name","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.spec.resources[*].type","title":".spec.resources[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames","title":".status.acceptedNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.categories","title":".status.acceptedNames.categories","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.categories[*]","title":".status.acceptedNames.categories[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.kind","title":".status.acceptedNames.kind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.listKind","title":".status.acceptedNames.listKind","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.plural","title":".status.acceptedNames.plural","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.shortNames","title":".status.acceptedNames.shortNames","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.shortNames[*]","title":".status.acceptedNames.shortNames[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.acceptedNames.singular","title":".status.acceptedNames.singular","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.storedVersions","title":".status.storedVersions","text":""},{"location":"reference/crd/kube-bind.io/apiserviceexports/#v1alpha2-.status.storedVersions[*]","title":".status.storedVersions[*]","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/","title":"APIServiceNamespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#apiservicenamespace-crd-schema-reference-group-kube-bindio","title":"APIServiceNamespace CRD schema reference (group kube-bind.io)","text":"APIServiceNamespace defines how consumer namespaces map to service namespaces. These objects are created by the konnector, and a service namespace is then created by the service provider.  The name of the APIServiceNamespace equals the namespace name in the consumer cluster.  Full name: apiservicenamespaces.kube-bind.io Group: kube-bind.io Singular name: apiservicenamespace Plural name: apiservicenamespaces Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies a service namespace.</p> object <p>status contains reconciliation information for a service namespace</p> string <p>namespace is the service provider namespace name that will be bound to the consumer namespace named like this object.</p>"},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha1-.status.namespace","title":".status.namespace","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object <p>spec specifies a service namespace.</p> object <p>status contains reconciliation information for a service namespace</p> string <p>namespace is the service provider namespace name that will be bound to the consumer namespace named like this object.</p>"},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/apiservicenamespaces/#v1alpha2-.status.namespace","title":".status.namespace","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/","title":"ClusterBinding","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#clusterbinding-crd-schema-reference-group-kube-bindio","title":"ClusterBinding CRD schema reference (group kube-bind.io)","text":"ClusterBinding represents a bound consumer cluster. It lives in a service provider cluster and is a singleton named \"cluster\" per namespace.  Full name: clusterbindings.kube-bind.io Group: kube-bind.io Singular name: clusterbinding Plural name: clusterbindings Scope: Namespaced Versions: v1alpha1v1alpha2"},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1","title":"Version v1alpha1","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#property-details-v1alpha1","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec represents the data in the newly created ClusterBinding.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different ServiceBindings.</p> object <p>serviceProviderSpec contains all the data and information about the service which has been bound to the service binding request. The service providers decide what they need and what to configure based on what then include in this field, such as service region, type, tiers, etc\u2026</p> object <p>status contains reconciliation information for the service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>heartbeatInterval is the maximal interval between heartbeats that the konnector promises to send. The service provider can assume that the konnector is not unhealthy if it does not receive a heartbeat within this time.</p> string <p>konnectorVersion is the version of the konnector that is running on the consumer cluster.</p> string <p>lastHeartbeatTime is the last time the konnector updated the status.</p>"},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.providerPrettyName","title":".spec.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.spec.serviceProviderSpec","title":".spec.serviceProviderSpec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.heartbeatInterval","title":".status.heartbeatInterval","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.konnectorVersion","title":".status.konnectorVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha1-.status.lastHeartbeatTime","title":".status.lastHeartbeatTime","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2","title":"Version v1alpha2","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#property-details-v1alpha2","title":"Properties","text":"string <p>APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources</p> string <p>Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p> object object Required <p>spec represents the data in the newly created ClusterBinding.</p> object Required <p>kubeconfigSecretName is the secret ref that contains the kubeconfig of the service cluster.</p> string Required <p>The key of the secret to select from.  Must be \u201ckubeconfig\u201d.</p> string Required <p>Name of the referent.</p> string Required <p>providerPrettyName is the pretty name of the service provider cluster. This can be shared among different ServiceBindings.</p> object <p>serviceProviderSpec contains all the data and information about the service which has been bound to the service binding request. The service providers decide what they need and what to configure based on what then include in this field, such as service region, type, tiers, etc\u2026</p> object <p>status contains reconciliation information for the service binding.</p> array <p>conditions is a list of conditions that apply to the ClusterBinding. It is updated by the konnector and the service provider.</p> object <p>Condition defines an observation of a object operational state.</p> string Required <p>Last time the condition transitioned from one status to another. This should be when the underlying condition changed. If that is not known, then using the time when the API field changed is acceptable.</p> string <p>A human readable message indicating details about the transition. This field may be empty.</p> string <p>The reason for the condition\u2019s last transition in CamelCase. The specific API may choose whether or not this field is considered a guaranteed API. This field may not be empty.</p> string <p>Severity provides an explicit classification of Reason code, so the users or machines can immediately understand the current situation and act accordingly. The Severity field MUST be set only when Status=False.</p> string Required <p>Status of the condition, one of True, False, Unknown.</p> string Required <p>Type of condition in CamelCase or in foo.example.com/CamelCase. Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important.</p> string <p>heartbeatInterval is the maximal interval between heartbeats that the konnector promises to send. The service provider can assume that the konnector is not unhealthy if it does not receive a heartbeat within this time.</p> string <p>konnectorVersion is the version of the konnector that is running on the consumer cluster.</p> string <p>lastHeartbeatTime is the last time the konnector updated the status.</p>"},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.apiVersion","title":".apiVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.kind","title":".kind","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.metadata","title":".metadata","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec","title":".spec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.kubeconfigSecretRef","title":".spec.kubeconfigSecretRef","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.kubeconfigSecretRef.key","title":".spec.kubeconfigSecretRef.key","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.kubeconfigSecretRef.name","title":".spec.kubeconfigSecretRef.name","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.providerPrettyName","title":".spec.providerPrettyName","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.spec.serviceProviderSpec","title":".spec.serviceProviderSpec","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status","title":".status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions","title":".status.conditions","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*]","title":".status.conditions[*]","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].lastTransitionTime","title":".status.conditions[*].lastTransitionTime","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].message","title":".status.conditions[*].message","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].reason","title":".status.conditions[*].reason","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].severity","title":".status.conditions[*].severity","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].status","title":".status.conditions[*].status","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.conditions[*].type","title":".status.conditions[*].type","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.heartbeatInterval","title":".status.heartbeatInterval","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.konnectorVersion","title":".status.konnectorVersion","text":""},{"location":"reference/crd/kube-bind.io/clusterbindings/#v1alpha2-.status.lastHeartbeatTime","title":".status.lastHeartbeatTime","text":""},{"location":"setup/","title":"Setting Up kube-bind","text":""},{"location":"setup/#quickstart","title":"Quickstart","text":"<p>Get started with kube bind.</p>"},{"location":"setup/#local-kube-bind-with-kind","title":"Local kube-bind with kind","text":""},{"location":"setup/#installation-with-helm","title":"Installation with Helm","text":"<p>Install kube-bind on an existing Kubernetes cluster via the official Helm chart.</p>"},{"location":"setup/#kubectl-plugins","title":"kubectl Plugins","text":"<p>How to install and use the kubectl bind plugin.</p>"},{"location":"setup/helm/","title":"Installation with Helm","text":"<p>If you reading this, we need help populating this page :)</p>"},{"location":"setup/kubectl-plugin/","title":"kubectl Plugins","text":"<p>kube-bind provides kubectl plugins to interact with kube-bind protocol.</p> <p>or use krew:</p> <pre><code>$ kubectl krew index add bind https://github.com/kube-bind/krew-index.git\n$ kubectl krew install bind/bind\n</code></pre>"},{"location":"setup/local-setup-with-kind/","title":"Local kube-bind with kind","text":"<p>This guide will walk you through setting up kube-bind between two Kubernetes clusters, where</p> <ul> <li>Backend cluster:</li> <li>Deploys dex, cert-manager and kube-bind/example-backend</li> <li>Provides kube-bind compatible backend for MangoDB resources</li> <li>App cluster:</li> <li>Provides an application consuming MangoDBs</li> </ul>"},{"location":"setup/local-setup-with-kind/#pre-requisites","title":"Pre-requisites","text":"<p>To start, you'll need following tools available in your system or a VM:</p> <ul> <li><code>kind</code></li> <li><code>kubectl</code></li> <li><code>kubectl-bind</code> (a kubectl plugin)</li> <li><code>helm</code></li> <li><code>jq</code></li> </ul> <p>To install <code>kubectl-bind</code> plugin, please download the archive for your platform from the link above, extract it, and place the <code>kubectl-bind</code> executable in your system's <code>$PATH</code>.</p> <p>Tip: In case of encountering <code>Too many open files</code> error when deploying the Kind clusters, run following commands:</p> <pre><code>sudo sysctl fs.inotify.max_user_watches=524288\nsudo sysctl fs.inotify.max_user_instances=512\n</code></pre> <p>See the kind documentation for more details.</p>"},{"location":"setup/local-setup-with-kind/#provider-cluster","title":"Provider cluster","text":"<p>The provider cluster we'll prepare in this section will provide a kube-bind compatible backend that will provide a controller for a demo resource \"MangoDB\" we'll consume in another cluster later.</p> <p>What is MangoDB? It is just an example CRD to demonstrate kube-bind's capabilities and testing, without any workloads. See its definition in /test/e2e/bind/fixtures/provider/crd-mangodb.yaml.</p>"},{"location":"setup/local-setup-with-kind/#step-one-create-the-backend-cluster","title":"Step one: create the Backend cluster","text":"<p>First, stash the host's external IP in a variable as we're going to use it often:</p> <pre><code>export BACKEND_HOST_IP=\"$(hostname -i | cut -d' ' -f1)\"\n</code></pre> <p>Create a Kind cluster named \"backend\":</p> <pre><code>cat &lt;&lt; EOF_BackendClusterDefinition | kind create cluster --config=-\napiVersion: kind.x-k8s.io/v1alpha4\nkind: Cluster\nname: backend\nnetworking:\n  apiServerAddress: ${BACKEND_HOST_IP}\nnodes:\n- role: control-plane\n  extraPortMappings:\n  # MangoDB export endpoint\n  - containerPort: 30080\n    hostPort: 8080\n    protocol: TCP\n  # dex endpoint\n  - containerPort: 30556\n    hostPort: 5556\n    protocol: TCP\nEOF_BackendClusterDefinition\n</code></pre> <p>Note: the port mappings will become clear later on, but in general this setup is solely specific to how Kind exposes ports of its nodes on the host. Specifically, we're exposing ports from containers through NodePort services on Kind's nodes, and to make these ports available on the host we need to map them to host's ports through <code>extraPortMappings</code>.</p>"},{"location":"setup/local-setup-with-kind/#step-two-deploy-an-identity-provider","title":"Step two: deploy an identity provider","text":"<p>kube-bind relies on OAuth2 for securely authenticating consumer and producer clusters. There are many ways to handle that in Kubernetes, for example with dex IDP. It depends on cert-manager, which we'll deploy first:</p> <pre><code>helm repo add jetstack https://charts.jetstack.io\nhelm install \\\n    --create-namespace \\\n    --namespace pki \\\n    --version v1.16.2 \\\n    --set crds.enabled=true \\\n    cert-manager jetstack/cert-manager\n</code></pre> <p>And now let's deploy dex:</p> <pre><code>helm repo add dex https://charts.dexidp.io\ncat &lt;&lt; EOF_DEXDeploymentConfig |\nconfig:\n    staticClients:\n      - id: kube-bind\n        redirectURIs:\n          - 'http://${BACKEND_HOST_IP}:8080/callback'\n        name: 'Kube Bind'\n        secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n\n    issuer: http://${BACKEND_HOST_IP}:5556/dex\n\n    storage:\n      type: kubernetes\n      config:\n        inCluster: true\n\n    web:\n      http: 127.0.0.1:5556\n\n    telemetry:\n      http: 127.0.0.1:5558\n\n    grpc:\n      addr: 127.0.0.1:5557\n\n    connectors:\n      - type: mockCallback\n        id: mock\n        name: Example\n\n    enablePasswordDB: true\n    staticPasswords:\n      - email: \"admin@example.com\"\n        hash: \"\\$2a\\$10\\$2b2cU8CPhOTaGrs1HRQuAueS7JTT5ZHsHSzYiFPm1leZck7Mc8T4W\"\n        username: \"admin\"\n        userID: \"08a8684b-db88-4b73-90a9-3cd1661f5466\"\nEOF_DEXDeploymentConfig\nhelm install \\\n    --create-namespace \\\n    --namespace idp \\\n    --set service.type=NodePort \\\n    --set service.ports.http.nodePort=30556 \\\n    dex dex/dex \\\n    -f -\n</code></pre>"},{"location":"setup/local-setup-with-kind/#step-three-deploy-the-mangodb-kube-bind-backend","title":"Step three: deploy the MangoDB kube-bind backend","text":"<p>Now we'll deploy a kube-bind--compatible backend for MangoDB. Let's start with kube-bind CRDs:</p> <pre><code>kubectl apply -f deploy/crd\n</code></pre> <p>And now CRDs for MangoDB:</p> <pre><code>kubectl apply -f test/e2e/bind/fixtures/provider/crd-mangodb.yaml\n</code></pre> <p>To set up the MangoDB backend we'll need: * ServiceAccount and ClusterRoleBinding for kube-bind's user, * Deployment that runs the MangoDB backend * Service that exposes the backend's address</p> <pre><code>kubectl create namespace backend\n# This is the address that will be used when generating kubeconfigs the App cluster,\n# and so we need to be able to reach it from outside.\nexport BACKEND_KUBE_API_EXTERNAL_ADDRESS=\"$(kubectl config view --minify -o json | jq '.clusters[0].cluster.server' -r)\"\n# For demo example let's just bind \"cluster-admin\" ClusterRole to backend's \"default\" ServiceAccount.\nkubectl create clusterrolebinding backend-admin --clusterrole cluster-admin --serviceaccount backend:default\n# Create a new Deployment for the MangoDB backend.\nkubectl --namespace backend \\\n    create deployment mangodb \\\n    --image ghcr.io/kube-bind/example-backend:v0.4.6 \\\n    --port 8080 \\\n    -- /ko-app/example-backend \\\n        --listen-address 0.0.0.0:8080 \\\n        --external-address \"${BACKEND_KUBE_API_EXTERNAL_ADDRESS}\" \\\n        --oidc-issuer-client-secret=ZXhhbXBsZS1hcHAtc2VjcmV0 \\\n        --oidc-issuer-client-id=kube-bind \\\n        --oidc-issuer-url=http://${BACKEND_HOST_IP}:5556/dex \\\n        --oidc-callback-url=http://${BACKEND_HOST_IP}:8080/callback \\\n        --pretty-name=\"BigCorp.com\" \\\n        --namespace-prefix=\"kube-bind-\" \\\n        --cookie-signing-key=bGMHz7SR9XcI9JdDB68VmjQErrjbrAR9JdVqjAOKHzE= \\\n        --cookie-encryption-key=wadqi4u+w0bqnSrVFtM38Pz2ykYVIeeadhzT34XlC1Y=\n# Expose mangodb's container port 8080 as a NodePort at 30080. We've already configured\n# Kind to expose 30800 at host's 8080.\nkubectl --namespace backend \\\n    create service nodeport mangodb \\\n    --tcp 8080 \\\n    --node-port 30080\n</code></pre> <p>And that's really all there's to it. After that, you should see a kubectl output similar to this:</p> <pre><code>$ kubectl --namespace backend get all\nNAME                          READY   STATUS    RESTARTS   AGE\npod/mangodb-6ff44cbbf-x7cjm   1/1     Running   0          100s\n\nNAME              TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE\nservice/mangodb   NodePort   10.96.10.212   &lt;none&gt;        8080:30080/TCP   100s\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/mangodb   1/1     1            1           100s\n\nNAME                                DESIRED   CURRENT   READY   AGE\nreplicaset.apps/mangodb-6ff44cbbf   1         1         1       100s\n</code></pre>"},{"location":"setup/local-setup-with-kind/#consumer-app-cluster","title":"Consumer App cluster","text":"<p>The App cluster will consume MangoDB CRs provided by the Backend.</p>"},{"location":"setup/local-setup-with-kind/#step-one-create-the-app-cluster","title":"Step one: create the App cluster","text":"<p>Again, let's start by stashing the host's external IP in a variable as we're going to use it often (possibly the same one as for the Backend cluster):</p> <pre><code>export APP_HOST_IP=\"$(hostname -i | cut -d' ' -f1)\"\n</code></pre> <p>Create a Kind cluster named \"app\":</p> <pre><code>cat &lt;&lt; EOF_AppClusterDefinition | kind create cluster --config=-\napiVersion: kind.x-k8s.io/v1alpha4\nkind: Cluster\nname: app\nnetworking:\n  apiServerAddress: ${APP_HOST_IP}\nEOF_AppClusterDefinition\n</code></pre>"},{"location":"setup/local-setup-with-kind/#binding-mangodb-backend","title":"Binding MangoDB backend","text":"<p>Now we'll bring in MangoDB CRDs from the Backend cluster (you can run <code>kubectl get crds</code> to see there are none yet):</p> <pre><code>$ kubectl bind http://${BACKEND_HOST_IP}:8080/export\nDISCLAIMER: This is a prototype. It will change in incompatible ways at any time.\n\n\ud83d\udce6 Created kube-bind namespace.\n\n\n\nTo authenticate, visit in your browser:\n\n    http://${BACKEND_HOST_IP}:8080/authorize?c=3QnoGw&amp;p=39595&amp;s=b2YLH6\n</code></pre> <p>The client is now waiting for you to visit the address similar to the one displayed in the output above. After completing the steps to create an OAuth2 token, it is then used by the kube-bind backend to pass the ServiceAccount's kubeconfig (in the Backend cluster) to the App cluster securely: 1. on the \"Log in to dex\" landing page, select \"Log in with Example\", 2. on the \"Grant Access\" page, click the \"Grant Access\" button, 3. lastly, click \"Bind\" when the page displays the mangodb resource.</p> <p>Go back to the terminal where <code>kubectl bind</code> command was run, and you should see the following output: <pre><code>\ud83d\udd11 Successfully authenticated to http://${BACKEND_HOST_IP}:8080/export\n\ud83d\udd12 Created secret kube-bind/kubeconfig-x9bd5 for host https://${BACKEND_HOST_IP}:34595, namespace kube-bind-gfsqn\n\ud83d\ude80 Executing: kubectl bind apiservice --remote-kubeconfig-namespace kube-bind --remote-kubeconfig-name kubeconfig-x9bd5 -f -\n\u2728 Use \"-o yaml\" and \"--dry-run\" to get the APIServiceExportRequest.\n   and pass it to \"kubectl bind apiservice\" directly. Great for automation.\n\ud83d\ude80 Deploying konnector v0.4.6 to namespace kube-bind.\n   Waiting for the konnector to be ready..............\n\u2705 Created APIServiceBinding mangodbs.mangodb.com\n\nNAME                                                  PROVIDER   READY   MESSAGE   AGE\napiservicebinding.kube-bind.io/mangodbs.mangodb.com              False   Pending   0s\n</code></pre></p>"},{"location":"setup/local-setup-with-kind/#step-two-demo-time","title":"Step two: demo time!","text":"<p>Let's see if we have CRDs for the MangoDB resource:</p> <pre><code>$ kubectl get crds\nNAME                              CREATED AT\napiservicebindings.kube-bind.io   2024-12-19T08:46:13Z\nmangodbs.mangodb.com              2024-12-19T08:46:17Z\n</code></pre> <p>We do! Now create a CR for it:</p> <pre><code>kubectl create -f - &lt;&lt; EOF_MangoDBDefinition\napiVersion: mangodb.com/v1alpha1\nkind: MangoDB\nmetadata:\n  name: my-db\nspec:\n  tokenSecret: my-secret\n  region: eu-west-1\n  tier: Shared\nEOF_MangoDBDefinition\nkubectl describe mangodb my-db\n</code></pre> <p>And finally, switch to the backend cluster and see that the CR is mirrored there: <pre><code>$ kubectl config use-context kind-backend\nSwitched to context \"kind-backend\".\n# Your \"kube-bind-&lt;Generated string&gt;-default\" will be different.\n$ kubectl -n kube-bind-rp2s9-default describe mangodb my-db\nName:         my-db\nNamespace:    kube-bind-rp2s9-default\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\nAPI Version:  mangodb.com/v1alpha1\nKind:         MangoDB\nMetadata:\n  Creation Timestamp:  2024-12-19T08:48:07Z\n  Generation:          1\n  Resource Version:    1564\n  UID:                 bed9f6d6-79d5-4535-8b20-690470b23378\nSpec:\n  Backup:        false\n  Region:        eu-west-1\n  Tier:          Shared\n  Token Secret:  my-secret\nEvents:          &lt;none&gt;\n</code></pre></p>"},{"location":"setup/local-setup-with-kind/#step-three-clean-up","title":"Step three: clean up","text":"<p>Once you're done, you may clean up the setup simply by deleting the two kind clusters:</p> <pre><code>kind delete cluster --name backend\nkind delete cluster --name app\n</code></pre>"},{"location":"setup/quickstart/","title":"Quickstart","text":""},{"location":"setup/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>kubectl</li> </ul>"},{"location":"setup/quickstart/#start-with-kube-bind","title":"Start with Kube-Bind","text":"<p>This section allows you to run local kube-bind backend and konnector. The main challenge when running it locally is to have multiple clusters available and accessible.</p> <p>For this we use kcp to create a local clusters under single kcp instance. By having a single kcp instance, we can have multiple clusters available and accessible via same url.</p> <p>To run kcp, you need to have a kcp binary.</p> <pre><code>$ make run-kcp\n</code></pre> <p>To run the current backend, there must be an OIDC issuer installed in place to do the the oauth2 workflow.</p> <p>We use dex to manage OIDC, following the steps below you can run a local OIDC issuer using dex:</p> <ul> <li>First, clone the dex repo: <code>git clone https://github.com/dexidp/dex.git</code></li> <li><code>cd dex</code> and then build the dex binary <code>make build</code></li> <li>The binary will be created in <code>bin/dex</code></li> <li>Adjust the config file(<code>examples/config-dev.yaml</code>) for dex by specifying the server callback method:   <pre><code>staticClients:\n- id: kube-bind\n  redirectURIs:\n  - 'http://127.0.0.1:8080/callback'\n  name: 'Kube Bind'\n  secret: ZXhhbXBsZS1hcHAtc2VjcmV0\n</code></pre></li> <li>Run dex: <code>./bin/dex serve examples/config-dev.yaml</code></li> </ul> <p>Next you should be able to run the backend. For it you need a kubernetes cluster (e.g. kind) accessible.</p> <p>Note: make sure before running the backend that you have the dex server up and running as mentioned above and that you have at least one k8s cluster. Take a look at the backend option in the cmd/main.go file</p> <p>Create copy of kcp kubeconfig and create provider cluster:</p> <pre><code>cp .kcp/admin.kubeconfig .kcp/provider.kubeconfig\nexport KUBECONFIG=.kcp/provider.kubeconfig\nkubectl ws create provider --enter\n</code></pre> <ul> <li>apply the CRDs:</li> </ul> <p><pre><code>kubectl apply -f deploy/crd\n</code></pre> * In order to populate binding list on website, we need a CRD with label <code>kube-bind.io/exported: true</code>. Apply example APIResourceSchema for the CRD: <code>kubectl apply -f deploy/examples/crd-mangodb.yaml</code></p> <pre><code>kubectl apply -f deploy/examples/crd-mangodb.yaml\nkubectl apply -f deploy/examples/crd-foo.yaml\n</code></pre> <ul> <li>start the backend binary with the right flags:    <pre><code>make build\n\nbin/backend \\\n  --oidc-issuer-client-secret=ZXhhbXBsZS1hcHAtc2VjcmV0 \\\n  --oidc-issuer-client-id=kube-bind \\\n  --oidc-issuer-url=http://127.0.0.1:5556/dex \\\n  --oidc-callback-url=http://127.0.0.1:8080/callback \\\n  --pretty-name=\"BigCorp.com\" \\\n  --namespace-prefix=\"kube-bind-\" \\\n  --cookie-signing-key=bGMHz7SR9XcI9JdDB68VmjQErrjbrAR9JdVqjAOKHzE= \\\n  --cookie-encryption-key=wadqi4u+w0bqnSrVFtM38Pz2ykYVIeeadhzT34XlC1Y= \\\n  --consumer-scope=cluster\n</code></pre></li> </ul> <p>where <code>ZXhhbXBsZS1hcHAtc2VjcmV0</code> matches the value of the dex config file.</p> <p>The <code>--cookie-signing-key</code> and <code>--cookie-encryption-key</code> settings can be generated using:</p> <pre><code>$ openssl rand -base64 32\nWQh88mNOY0Z3tLy1/WOud7qIEEBxz+POc4j8BsYenYo=\n</code></pre> <p>The <code>--cookie-signing-key</code> option is required and supports 32 and 64 byte lengths. The <code>--cookie-encryption-key</code> option is optional and supports byte lengths of 16, 24, 32 for AES-128, AES-192, or AES-256.</p>"},{"location":"setup/quickstart/#consumer","title":"Consumer","text":"<p>Now create consumer cluster:</p> <pre><code>export KUBECONFIG=.kcp/admin.kubeconfig\nkubectl ws create consumer --enter\n</code></pre> <p>Now create the APIServiceExportRequest:</p> <pre><code>./bin/kubectl-bind http://127.0.0.1:8080/exports --dry-run -o yaml &gt; apiserviceexport.yaml\n\n# This will wait for konnector to be ready. Once this gets running - start the konnector bellow\n# IMPORTANT: Check namespace to be used!\n./bin/kubectl-bind apiservice --remote-kubeconfig .kcp/provider.kubeconfig -f apiserviceexport.yaml  --skip-konnector --remote-namespace &lt;namespace&gt;\n\n# run konnector in different terminal\nexport KUBECONFIG=.kcp/admin.kubeconfig\ngo run ./cmd/konnector/ --lease-namespace default\n</code></pre> <p>Create mangoDB object:</p> <pre><code>kubectl create -f deploy/examples/mangodb.yaml\n</code></pre>"}]}